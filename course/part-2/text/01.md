# 2.01 - Value Object and QObject

## The Meta-Object system

Qt's meta-object system provides the signals and slots mechanism for inter-object communication, run-time type information (RTTI), and the dynamic property system. Signals and slots is one of the most important concepts in Qt, and it will be discussed in the next chapter.

The meta-object system is implemented with a three-part mechanism:

- `QObject` is the base class that all objects in the meta-object system inherit from.
- The `Q_OBJECT` macro is used to enable meta-object features when declared within a class definition.
- The Meta-Object Compiler (`moc`) will read the class definitions with the declared `Q_OBJECT` macro and produce the meta-object code.

## Value Type and Identity Type

Value types can be copied and assigned. Many of the Qt value types, such as `QString` and Qt Containers, also use implicit sharing (copy-on-write). Implicitly shared classes are both safe and efficient when passed as arguments, because only a pointer to the data is passed around, and the data is copied only if and when a function writes to it. Custom value types can be made known to the meta-object system by using the `Q_DECLARE_METATYPE` macro, which makes them storable in `QVariant`. This is useful when, for example, reading properties. How this is done will be discussed later in the chapter, with the property system in general.

Identity type in turn derives from `QObject`. It extends C++ with many dynamic features using a meta-object system. `QObject` has neither a copy constructor nor an assignment operator; this is by design. Actually, they are declared, but in a private section with the macro `Q_DISABLE_COPY()`. In fact, all Qt classes derived from `QObject` (direct or indirect) use this macro to declare their copy constructor and assignment operator to be private. The main consequence is that you should use pointers to `QObject` (or to your `QObject` subclass) where you might otherwise be tempted to use your `QObject` subclass as a value. For example, without a copy constructor, you can't use a subclass of `QObject` as the value to be stored in one of the container classes. You must store pointers.

## The Qt Object Model and the QObject class

The `QObject` class is the base class of all Qt objects. It is the heart of the Qt Object Model. The central feature in this model is a very powerful mechanism for seamless object communication called signals and slots. The signals and slots system will be discussed at length in the next chapter. 

`QObject`s organize themselves in object trees. When you create a `QObject` with another object as parent, the object will automatically add itself to the parent's `children()` list. The parent takes ownership of the object; i.e., it will automatically delete its children in its destructor. You can look for an object by name and optionally type using `findChild()` or `findChildren()`. The parent-child relationship will be discussed in chapter 2.03.

Every object has an `objectName()` and its class name can be found via the corresponding `metaObject()` (see `QMetaObject::className()`). You can determine whether the object's class inherits another class in the `QObject` inheritance hierarchy by using the `inherits()` function.

When an object is deleted, it emits a `destroyed()` signal. You can catch this signal to avoid dangling references to `QObject`s.

Last but not least, `QObject` provides the basic timer support in Qt; see `QTimer` for high-level support for timers.

### The `Q_OBJECT` macro

The `Q_OBJECT` macro must appear in the private section of a class definition that declares its own signals and slots or that uses other services provided by Qt's meta-object system.

The `moc` tool reads a C++ header file. If it finds one or more class declarations that contain the `Q_OBJECT` macro, it produces a C++ source file containing the meta-object code for those classes. This meta-object code implements the underlying functionality needed for the runtime features. When using `qmake` you don't have to manually run the `moc` tool, it will be done automatically.

Example:

```cpp
#include <QObject>

class Counter : public QObject
{
    Q_OBJECT

public:
    Counter() { m_value = 0; }
    int value() const { return m_value; }

public slots:
    void setValue(int value);

signals:
    void valueChanged(int newValue);

private:
    int m_value;
};
```

This macro requires the class to be a subclass of `QObject`. You can use `Q_GADGET` instead of `Q_OBJECT` to enable the meta object system's support for enums in a class that is not a `QObject` subclass. The `Q_GADGET` macro is a lighter version of the `Q_OBJECT` macro for classes that do not inherit from `QObject` but still want to use some of the reflection capabilities offered by `QMetaObject`. Just like the `Q_OBJECT` macro, it must appear in the private section of a class definition.

Notice that the `Q_OBJECT` macro is mandatory for any object that implements signals, slots or properties. We strongly recommend the use of this macro in all subclasses of `QObject` regardless of whether or not they actually use signals, slots and properties, since failure to do so may lead certain functions to exhibit strange behavior.
{: .note}

### Internationalization (I18n)

All `QObject` subclasses support Qt's translation features, making it possible to translate an application's user interface into different languages.

To make user-visible text translatable, it must be wrapped in calls to the `tr()` function. This is explained in detail in the [Writing Source Code for Translation](https://doc.qt.io/qt-5/i18n-source-translation.html) document. We won't be covering internationalization on this course, but it's good to know it's there.

## The Property System

Qt provides a sophisticated [property system](http://doc.qt.io/qt-5/properties.html) similar to the ones supplied by some compiler vendors. However, as a compiler- and platform-independent library, Qt does not rely on non-standard compiler features like `__property` or `[property]`. The Qt solution works with any standard C++ compiler on every platform Qt supports. It is based on the Meta-Object System that also provides the signals and slots system.

### Requirements for Declaring Properties

To declare a property, use the `Q_PROPERTY()` macro in a class that inherits `QObject`. Here is an example showing how to export member variables as Qt properties using the `MEMBER` keyword. Note that a `NOTIFY` signal must be specified to allow QML property bindings. We will talk more about QML in Part 3!

```cpp
Q_PROPERTY(QColor color MEMBER m_color NOTIFY colorChanged)
Q_PROPERTY(qreal spacing MEMBER m_spacing NOTIFY spacingChanged)
Q_PROPERTY(QString text MEMBER m_text NOTIFY textChanged)

...

signals:
    void colorChanged();
    void spacingChanged();
    void textChanged(const QString &newText);

private:
    QColor  m_color;
    qreal   m_spacing;
    QString m_text;
```

A property behaves like a class data member, but it has additional features accessible through the [Meta-Object System](http://doc.qt.io/qt-5/metaobjects.html).

The property declaration syntax has multiple keywords to specify the behaviour of the declared property. Here are the most relevant ones:

|-----------------------------|----------------|
| `READ`      | For reading the property value. Ideally a const function is used for this purpose, and it must return either the property's type or a const reference to that type. eg., `QWidget::focus` is a read-only property with READ function, `QWidget::hasFocus()`. Required if no `MEMBER` variable was specified. |
| `WRITE`     | For setting the property value. It must return void and must take exactly one argument, either of the property's type or a pointer or reference to that type. e.g., `QWidget::enabled` has the `WRITE` function `QWidget::setEnabled()`. Read-only properties do not need `WRITE` functions. e.g., `QWidget::focus` has no `WRITE` function. |
| `MEMBER`    | Required if no `READ` accessor function is specified. This makes the given member variable readable and writable without the need of creating `READ` and `WRITE` accessor functions. It's still possible to use `READ` or `WRITE` accessor functions in addition to `MEMBER` variable association (but not both), if you need to control the variable access.
| `RESET`     | Optional. For setting the property back to its context specific default value. e.g., `QWidget::cursor` has the typical `READ` and `WRITE functions`, `QWidget::cursor()` and `QWidget::setCursor()`, and it also has a `RESET` function, `QWidget::unsetCursor()`, since no call to `QWidget::setCursor()` can mean reset to the context specific cursor. The `RESET` function must return void and take no parameters. |
| `NOTIFY`    | Optional. If defined, it should specify one existing signal in that class that is emitted whenever the value of the property changes. `NOTIFY` signals for `MEMBER` variables must take zero or one parameter, which must be of the same type as the property. The parameter will take the new value of the property. The `NOTIFY` signal should only be emitted when the property has really been changed, to avoid bindings being unnecessarily re-evaluated in QML, for example. Qt emits automatically that signal when needed for `MEMBER` properties that do not have an explicit setter. |
| `USER`      | Attribute indicates whether the property is designated as the user-facing or user-editable property for the class. Normally, there is only one `USER` property per class (default false). e.g., `QAbstractButton::checked` is the user editable property for (checkable) buttons.

The property type can be any type supported by `QVariant`, or it can be a user-defined type. In this example, class `QDate` is considered to be a user-defined type.

```cpp
Q_PROPERTY(QDate date READ getDate WRITE setDate)
```

Because `QDate` is user-defined, you must include the `<QDate>` header file with the property declaration.

For historical reasons, `QMap` and `QList` as property types are synonym of `QVariantMap` and `QVariantList`.

### Reading and Writing Properties

A property can be read and written using the generic functions `QObject::property()` and `QObject::setProperty()`, without knowing anything about the owning class except the property's name. In the code snippet below, the call to `QAbstractButton::setDown()` and the call to `QObject::setProperty()` both set property "down".

```cpp
QPushButton *button = new QPushButton;
QObject *object = button;
button->setDown(true);
object->setProperty("down", true);
```

Accessing a property through its `WRITE` accessor is the better of the two, because it is faster and gives better diagnostics at compile time, but setting the property this way requires that you know about the class at compile time. Accessing properties by name lets you access classes you don't know about at compile time. You can discover a class's properties at run time by querying its `QObject`, `QMetaObject`, and `QMetaProperties`.

```cpp
QObject *object = ...
const QMetaObject *metaobject = object->metaObject();
int count = metaobject->propertyCount();
for (int i = 0; i < count; ++i) {
    QMetaProperty metaproperty = metaobject->property(i);
    const char *name = metaproperty.name();
    QVariant value = object->property(name);
    ...
}
```

In the above snippet, `QMetaObject::property()` is used to get metadata about each property defined in some unknown class. The property name is fetched from the metadata and passed to `QObject::property()` to get the value of the property in the current object.

### Example

Suppose we have a class MyClass, which is derived from `QObject` and which uses the `Q_OBJECT` macro in its private section. We want to declare a property in MyClass to keep track of a priority value. The name of the property will be priority, and its type will be an enumeration type named `Priority`, which is defined in MyClass.

We declare the property with the `Q_PROPERTY()` macro in the private section of the class. The required READ function is named priority, and we include a WRITE function named `setPriority`.

The enumeration type must be registered with the Meta-Object System using the `Q_ENUM()` macro. The macro registers an enum type with the meta-object system. This will enable useful features; for example, if used in a `QVariant`, you can convert them to strings. Likewise, passing them to `QDebug` will print out their names. It must be placed after the enum declaration in a class that has the `Q_OBJECT` or the `Q_GADGET` macro.

Registering an enumeration type makes the enumerator names available for use in calls to `QObject::setProperty()`. We must also provide our own declarations for the READ and WRITE functions.

```cpp
class MyClass : public QObject
{
    Q_OBJECT
    Q_PROPERTY(Priority priority READ priority WRITE setPriority NOTIFY priorityChanged)

public:
    MyClass(QObject *parent = 0);
    ~MyClass();

    enum Priority { High, Low, VeryHigh, VeryLow };
    Q_ENUM(Priority)

    void setPriority(Priority priority);
    Priority priority() const;

    signals:
        void priorityChanged(Priority);
    
    private:
        Priority m_priority;
};
```


Given a pointer to an instance of MyClass or a pointer to a `QObject` that is an instance of MyClass, we have two ways to set its priority property:

```cpp
MyClass *myinstance = new MyClass;
QObject *object = myinstance;

myinstance->setPriority(MyClass::VeryHigh);
object->setProperty("priority", "VeryHigh");
```

In the example, the enumeration type that is the property type is declared in MyClass and registered with the Meta-Object System using the `Q_ENUM()` macro. This makes the enumeration values available as strings for use as in the call to `setProperty()`. Had the enumeration type been declared in another class, its fully qualified name (i.e., `OtherClass::Priority`) would be required, and that other class would also have to inherit `QObject` and register the enumeration type there using the `Q_ENUM()` macro.

A similar macro, `Q_FLAG()`, is also available. Like `Q_ENUM()`, it registers an enumeration type, but it marks the type as being a set of flags, i.e. values that can be OR'd together. An I/O class might have enumeration values `Read` and `Write` and then `QObject::setProperty()` could accept `Read | Write`. `Q_FLAG()` should be used to register this enumeration type.
{: .note}

### Dynamic Properties

`QObject::setProperty()` can also be used to add new properties to an instance of a class at runtime. When it is called with a name and a value, if a property with the given name exists in the `QObject`, and if the given value is compatible with the property's type, the value is stored in the property, and true is returned. If the value is not compatible with the property's type, the property is not changed, and false is returned. But if the property with the given name doesn't exist in the `QObject` (i.e., if it wasn't declared with `Q_PROPERTY()`), a new property with the given name and value is automatically added to the `QObject`, but false is still returned. This means that a return of false can't be used to determine whether a particular property was actually set, unless you know in advance that the property already exists in the `QObject`.

Note that dynamic properties are added on a per instance basis, i.e., they are added to `QObject`, not `QMetaObject`. A property can be removed from an instance by passing the property name and an invalid `QVariant` value to `QObject::setProperty()`. The default constructor for `QVariant` constructs an invalid `QVariant`.
{: .note}

Dynamic properties can be queried with `QObject::property()`, just like properties declared at compile time with `Q_PROPERTY()`.

### Properties and Custom Types

Custom value types used by properties need to be registered using the `Q_DECLARE_METATYPE()` macro so that their values can be stored in `QVariant` objects. This makes them suitable for use with both static properties declared using the `Q_PROPERTY()` macro in class definitions and dynamic properties created at run-time.

The declaration is done by putting the `Q_DECLARE_METATYPE()` macro in the header file of your custom class. For example:

```cpp
#include <QMetaType>

class YourCustomClass
{
public:
    YourCustomClass();
};

Q_DECLARE_METATYPE(YourCustomClass)
```

### Adding Additional Information to a Class

Connected to the property system is an additional macro, `Q_CLASSINFO()`, that can be used to attach additional name--value pairs to a class's meta-object, for example:

`Q_CLASSINFO("Version", "3.0.0")`

Like other meta-data, class information is accessible at run-time through the meta-object; see `QMetaObject::classInfo()` for details.

## Exercise - 01_TimeToReflect

In this exercise you'll get familiar with accessing QObject's properties. You'll find the instuctions in `reflection.cpp`.

Hint: `QVariant` will be useful.

## Exercise - 02_CustomContainer

This exercise is tad bit larger. You'll create a custom class `Student`, as well as implement the functionality for `StudentRegistry`. You'll find the instuctions in `studentregistry.cpp`.

