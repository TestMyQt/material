# 2.02 Object Communicating: Signals and Slots

Nearly all UI toolkits have a mechanism to detect a user action, and respond to this action. Some of them use callbacks, others use listeners, but basically, all of them are inspired by the observer pattern.

Observer pattern is used when an observable object wants to notify other observers objects about a state change. Here are some concrete examples:

* A user has clicked on a button, and a menu should be displayed.
* A web page just finished loading, and a process should extract some information from this loaded page.
* An user is scrolling through a list of items (in an app store for example), and reached the end, so other items should be loaded.

Observer pattern is used everywhere in GUI applications, and often leads to some boilerplate code. Qt was created with the idea of removing this boilerplate code and providing a nice and clean syntax, and the signal and slots mechanism is the answer.

Signals and slots are the key of Qt and object communication within. They are in a sense comparable to callbacks, but the difference is that they are type-safe where as callbacks typically are not. One of the benefits we could mention before starting, is that signals and slots allow you to build many-to-many connections, where as typically virtual methods are one-to-one or one-to-many, if several virtual functions are used.

We discussed the `Q_OBJECT` macro in the last chapter, and it will find some relevance throughout this topic as well.

## Briefly about Events

Before jumping into signals and slots, let's talk briefly about events. Events are executed in event loops. This is hardly specific to Qt, arguably most of the applications you use spend majority of their time in event loops which wait for input, let it be from user, network, or somewhere else. There can be multiple event loops, every thread will have one for example. Qt supports the use of [Event Handlers](http://doc.qt.io/qt-5/eventsandfilters.html#event-handlers), but in general you'll want to use the signal and slot system. Reason we are introducing events here is that you should understand the concept of event loops as it relates to signals and slots. In the course we'll be dealing with single-threaded applications, but when you [send signals across threads](http://doc.qt.io/qt-5/threads-qobject.html#signals-and-slots-across-threads) you should remember that the slot might not be executed immediately, and instead it might be placed in the receiving thread's event loop to wait until the control is given to that thread.

## Performance

Compared to callbacks, signals and slots are slightly slower because of the increased flexibility they provide, but the difference for real applications is insignificant. In general, emitting a signal that is connected to some slots, is approximately ten times slower than calling the receivers directly, with non-virtual function calls. This is the overhead required to locate the connection object, to safely iterate over all connections (i.e. checking that subsequent receivers have not been destroyed during the emission), and to marshall any parameters in a generic fashion.

While ten non-virtual function calls may sound like a lot, it's much less overhead than any new or delete operation, for example. As soon as you perform a string, vector or list operation that behind the scene requires new or delete, the signals and slots overhead is only responsible for a very small proportion of the complete function call costs. The same is true whenever you do a system call in a slot; or indirectly call more than ten functions. The simplicity and flexibility of the signals and slots mechanism is well worth the overhead, which your users won't even notice.


## Signals

Signals are emitted by an object when its internal state has changed in some way that might be interesting to the object's client or owner. Signals are public access functions and can be emitted from anywhere, but we recommend to only emit them from the class that defines the signal and its subclasses.

To define a signal, put it in the `signals:` block in the class definition:

```cpp
...
signals:
    void valueChanged(int newValue);
...
```

To emit a signal, you use the `emit` keyword. The keyword is purely syntactic, but it helps to differentiate it from normal function calls.

```cpp
void Counter::setValue(int value)
{
    if (value != m_value) {
        m_value = value;
        emit valueChanged(value);
    }
}
```

When a signal is emitted, the slots connected to it are usually executed immediately, just like a normal function call. When this happens, the signals and slots mechanism is totally independent of any GUI event loop. Execution of the code following the `emit` statement will occur once all slots have returned. The situation is slightly different when using queued connections; in such a case, the code following the emit keyword will continue immediately, and the slots will be executed later.

Here are some examples of signals from the `QPushButton` class:

* clicked
* pressed
* released

As you can see, their names are quite explicit. These signals are sent when the user clicked (pressed then released), pressed or released the button.

These signals are automatically generated by the moc (meta-object compiler) and must not be implemented in the .cpp file. They can never have return types (i.e. use void).

Developer experience shows that signals and slots are more reusable if they do not use special types. If `QScrollBar::valueChanged()` were to use a special type such as the hypothetical `QScrollBar::Range`, it could only be connected to slots designed specifically for `QScrollBar`. Connecting different input widgets together would be impossible.
{: .note}

## Slots

A slot is called when a signal connected to it is emitted. Slots are normal C++ functions and can be called normally; their only special feature is that signals can be connected to them.

Here are some slots, from different classes:

* `QApplication::quit`
* `QWidget::setEnabled`
* `QPushButton::setText`

If several slots are connected to one signal, the slots will be executed one after the other, in the order they have been connected, when the signal is emitted.

Since slots are normal member functions, they follow the normal C++ rules when called directly. However, as slots, they can be invoked by any component, regardless of its access level, via a signal-slot connection. This means that a signal emitted from an instance of an arbitrary class can cause a private slot to be invoked in an instance of an unrelated class.

## Signal/Slot definition

As mentioned in the previous chapter, all classes that use the signal/slot system need to have the `Q_OBJECT` macro in the private section of the classes definition. Here's an example of a header file for a class that implements both signals and slots.

```cpp
#include <QObject>

class Counter : public QObject
{
    Q_OBJECT

public:
    Counter() { m_value = 0; }

    int value() const { return m_value; }

public slots:
    void setValue(int value);

signals:
    void valueChanged(int newValue);

private:
    int m_value;
};
```

## Connecting Signals and Slots

To connect the signal to the slot, we use `QObject::connect()`. There are several ways to connect signal and slots. The first is to use function pointers:

```cpp
connect(sender, &QObject::destroyed, this, &MyObject::objectDestroyed);
```

There are several advantages to using `QObject::connect()` with function pointers. First, it allows the compiler to check that the signal's arguments are compatible with the slot's arguments. Arguments can also be implicitly converted by the compiler, if needed.

You can also connect to functors or C++11 lambdas:

```cpp
connect(sender, &QObject::destroyed, [=](){ this->m_objects.remove(sender); });
```

The traditional way to connect a signal to a slot is to use `QObject::connect()` and the `SIGNAL()` and `SLOT()` macros. It's presented here because it's still widely used, but in general, you should use one of the newer connection types presented before. The rule about whether to include arguments or not in the `SIGNAL()` and `SLOT()` macros, if the arguments have default values, is that the signature passed to the `SIGNAL()` macro must not have fewer arguments than the signature passed to the `SLOT()` macro.

All of these would work:

```cpp
connect(sender, SIGNAL(destroyed(QObject*)), this, SLOT(objectDestroyed(Qbject*)));
connect(sender, SIGNAL(destroyed(QObject*)), this, SLOT(objectDestroyed()));
connect(sender, SIGNAL(destroyed()), this, SLOT(objectDestroyed()));
```

But this one won't work:

```cpp
connect(sender, SIGNAL(destroyed()), this, SLOT(objectDestroyed(QObject*)));
```

...because the slot will be expecting a `QObject` that the signal will not send. This connection will report a runtime error. Note that signal and slot arguments are not checked by the compiler when using this `QObject::connect()` overload.

## Exercise - 03_SignalsSlots

In this exercise you'll create two classes to practise defining signals and slots. You'll find the exercise instructions in `main.cpp`.

## 3rd Party libraries

You might be familiar with other signals slot mechanisms, like the [Boost.Signals2 library](https://www.boost.org/doc/libs/1_63_0/doc/html/signals2.html). It is possible to use Qt with a 3rd party signal/slot mechanism or even use both mechanisms in the same project. Add the following definition to your projects (.pro) file.

```qmake
CONFIG += no_keywords
```

It tells Qt not to define the moc keywords `signals`, `slots`, and `emit`, because these names will be used by a 3rd party library, e.g. Boost. Then to continue using Qt signals and slots with the `no_keywords` flag, simply replace all uses of the Qt moc keywords in your sources with the corresponding Qt macros `Q_SIGNALS` (or `Q_SIGNAL`), `Q_SLOTS` (or `Q_SLOT`), and `Q_EMIT`.

## Further Reading

For more detailed information about Signals and Slots, see the official [Signal/Slot documentation](https://doc.qt.io/qt-5/signalsandslots.html).

