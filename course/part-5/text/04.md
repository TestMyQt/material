# 5.04 - C++ Models in QML

We've talked about making your own models to present data in QML few times now, and in the last chapter we saw basic example of `QStandardItemModel`. Often it's needed to implement your own model from the start for performance and functionality reasons. `QAbstactItemModel` class provides the abstract interface for item model classes, and it can be subclassed to create your own models. `QAbstractListModel` and `QAbstractTableModel` inherit `QAbstractItemModel` and can be subclassed instead when making list or table models. In this chapter we'll be taking a closer look at `QAbstractTableModel`.

## QAbstractTableModel

When making your own table model by subclassing `QAbstractTableModel`, you must at the very least implement functions `rowCount()`, `columnCount()`, and `data()`. It's also recommended to implement `headerData()`.

To make our model available in QML we also need to reimplement `roleNames` (like in the `QStandardItemModel` example in the last chapter).

Editable models need to also implement `setData()` and `flags()`.

Models that provide interfaces to resizable data structures can provide implementations for inserting and removing rows and columns as well, but if you do so it's important to remember to call appropriate functions so that all connected views are aware of any changes:

* `beginInsertRows()` / `beginInsertColumns()` must be called before inserting new rows and/or columns into the data structure, and `endInsertRows()` / `endInsertColumns()` immediately afterwards.
* `removeRows()`/ `removeColumns()` must be called before removing rows and/or columns from the data structure, and `endRemoveRows()` / `endRemoveColumsn()` immediately afterwards.

### Example

