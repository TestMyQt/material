# 3.02 QML Types and Properties

QML types are structures in the markup language, and they represent visual and non-visual parts. Non-visual QML types include functionality, such as states, transitions, models, paths, gradients and timers. 

// Seuraava kappale voisi alkaa, että Item on sit visual itemien perustyyppi. Vois jopa mainita että C++:ssa QQuickItem
// Sitten jatkaa, että Item ei ole näkyvä kuten alla
// Ei ohjeisteta käyttämään Rectanglea vaan mitä tahansa visuaalista tyyppiä, Rectangle, Image etc. Noita otsikon tyyppejä voisi mainita 
// tässä pelkän Rectanglen sijaan

// Ja site vielä. Tehdään selväski, että yleensä on Window tai sen alityyppi sovelluksen main.qml:n roottina. Omien komponenttien 
// juurena Item on hyvä. Koska wizard nykyään tekee ton Window-olion automaattisesti, niin yritetään olla sotkematta

All visual items in Qt Quick inherit from `Item`, but it's not itself visual. Using `Item` as the top-level QML object (as the root item of your component) will not produce a visual result. If you wish your top-level QML object to produce a visual result, you can use another type such as `Rectangle` or `Image` instead.

Note that even though `Item` is good as a root object for your own components, in the application's `main.qml` you'll usually want to use `Window` or one of its sub-types as the root object. When creating a new QML project with the Qt Creator wizard, the `Window` object is created automatically to `main.qml`.

// Eka lause tästä kappaleesta ennen kuin aletaan puhua Itemistä. Sit vois jatkaa. Although...
// key handling support => key focus handling

Although an `Item` object has no visual appearance, it defines all the attributes that are common across visual items, such as x and y position, width and height, anchoring and key focus handling. It supports layering and is usually used to group visual types. Use the `Item` to create opacity effects, such as when creating an invisible container to hold other components.

The `Item` type is useful for grouping several items under a single root visual item. For example:

```qml
import QtQuick 2.0

Item {
    id: root
    Text {
        text: "Hello There!"
        color: black
    }
    Image {
        id: imageOne
        x: 80
        width: 100
        height: 100
        source: "tile.png"
    }
    Image {
        id: imageTwo
        x: 190
        width: 100
        height: 100
        fillMode: Image.Tile
        source: "tile.png"
    }
}
```  
// You should bind. MITÄ? Ei ole selitetty bindauksesta vielä mitään. 
// Mikä on : ja = ero
// Ottaisin tähän myös esimerkin Qt.bindingista, että = ja bindingin ero tulee selväksi
// *J: Property bindeistä on nyt oma kappale edellisessä osassa, siellä on myös Qt.binding esimerkki*

Please note that we are only using "magic numbers" in the examples for clarity's sake. In general, you should try to bind x, y, width and height to the parent, or another item, such as the root item of the component. How to do this will be explained shortly.

We discussed properties at the end of the last chapter. You should note that the `id` property is a special property used to identify QML objects. It is used to create relationships between objects. The `id` property of an object allows other objects refer to it in regard to:

* Relative realignment and positioning
* To use its properties
* To change its properties (e.g. for animation)
* For re-use of common types (e.g. gradients, images).

For example:

```qml
Item { 
    width: 300; height: 115 
    Text { 
        id: title 
        x: 50; y: 25 
        text: "Qt Quick" 
        font { family: "Helvetica"; pointSize: parent.width * 0.1 } 
    } 
    
    Rectangle { 
        x: title.x; y: title.y + title.height - height; height: 5 
        width: title.width 
        color: "green" 
    }
} 
```

### Visual Parents and Children

// This section needs to be explained better I feel, it doesn't seem clear

// Tässä vähän toistetaan samaa asiaa. Vika lause on ainakin toistoa, eikö

The `QObject` parent-child relationship was discussed in Part 2. Now we will be taking a look at visual parents and children, as it's important to understand how the concept differs. An item's visual parent may not necessarily be the same as its object parent. The concept of the visual parent in Qt Quick is separate from, but related to, the concept of the object parent within the `QObject` parent hierarchy.

All QML objects have an object parent, which is determined by the object hierarchy in which the object is declared. When working with the `QtQuick` module, the `Item` type is the base type for all visual items provided by this module, and it provides the concept of an additional visual parent, as defined by an item's parent property. Every item has a visual parent; if an item's parent property value is `null`, the item will not be rendered in the scene.

Any object assigned to an item's data property becomes a child of the item within its `QObject` hierarchy, for memory management purposes. Additionally, if an object added to the data property is of the `Item` type, it is also assigned to the `Item::children` property and becomes a child of the item within the visual scene hierarchy. (Most Qt Quick hierarchy crawling algorithms, especially the rendering algorithms, only consider the visual parent hierarchy.)

For convenience, the `Item` data property is its default property. This means that any child item declared within an `Item` object without being assigned to a specific property is automatically assigned to the data property and becomes a child of the item as described above. So, the two code blocks below produce the same result, and you will almost always see the form shown below: 

```qml
import QtQuick 2.0

Item {
    width: 100; height: 100
    
    Rectangle { 
        width: 50;
        height: 50;
        color: "red"
    }
}
```

Rather than the explicit data assignment:

```qml
import QtQuick 2.0

Item {
    width: 100; height: 100

    data: [
        Rectangle {
            width: 50;
            height: 50;
            color: "red"
        }
    ]
}
```

An item's visual parent can be changed at any time by setting its parent property. Thus, an item's visual parent may not necessarily be the same as its object parent.

When an item becomes the child of another item:

* The child's parent refers to its parent item
* The parent's `children` and `childrenRect` properties take that child into account

Declaring an item as a child of another does not automatically mean that the child item will be appropriately positioned or sized to fit within its parent. Some QML types may have in-built behaviors that affect the positioning of child items — for example, a `Row` object automatically re-positions its children into a horizontal formation — but these are behaviors enforced by the types' own specific implementations. Additionally, a parent item will not automatically clip its children to visually contain them within the parent's visual bounds, unless its `clip` property is set to true.

// Binding-harkkaa kehiin jo. Menee liian pitkäksi

### QML Object Attributes

Every QML object type has a defined set of attributes. Each instance of an object type is created with the set of attributes that have been defined for that object type.

// Viittaus noihin property visibility-sääntöihin olis nyt tarpeen. Katsokaa alla. Lisäsin tuon according... *J: Pitää vielä lisätä tarkemmin visibility säännöt, sopisikohan sen kanssa samaan sitten vielä Attached Propertyt? + SIGNAL HANDLERIT*

A property is an attribute of an object that can be assigned a static value or bound to a dynamic JavaScript expression or even a code block. A property's value can be read by other objects according to property visibility scope rules. Generally it can also be modified by another object, unless a particular QML type has explicitly disallowed this for a specific property.

// Tähän pitäis saada viimeistään viittaus QObject-propertyihin. *J: Onko alla oleva riittävä vai halutaanko tarkemmin?*

A property may be defined for a type in C++ by registering a `Q_PROPERTY` of a class which is then registered with the QML type system. We discussed these `QObject` properties in the last part. Alternatively, a custom or dynamic property of an object type may be defined in an object declaration in a QML document or component with the following syntax:

```qml
[default] property <propertyType> <propertyName>
```

In this way an object declaration may expose a particular value to outside objects or maintain some internal state more easily.

// Aliakset componenttilukuun, jos mahdollista *J: Siirretty*

// BINDINGS!!!!! Vai onko ne seuraavassa osassa *J: Teen siitä oman osion nyt tähän, siirretään seuraavaan osioon jos ei sovi tänne*

### Grouped Properties

In some cases properties contain a logical group of sub-property attributes. These sub-property attributes can be assigned to using either the dot notation or group notation.

For example, the Text type has a font group property. Below, the first Text object initializes its font values using dot notation, while the second uses group notation:

```qml
Text {
    //dot notation
    font.pixelSize: 12
    font.b: true
}

Text {
    //group notation
    font { pixelSize: 12; b: true }
}
```

### Property Bindings

As we just mentioned, an object's property can be assigned a static value which stays constant until explicitly assigned a new value. However, to make the fullest use of QML and its built-in support for dynamic objecct behaviours, most QML objects use property bindings. Property bindings are a core feature of QML that lets developers specify relationships between different object properties. When property's dependencies change in value, the property is automatically updated according to the specified relationship.

Behind the scenes, the QML engine monitors the property's dependencies (that is, the variables in the binding expression). When a change is detected, the QML engine re-evaluates the binding expression and applies the new result to the property.

To create a property binding, a property is assigned a JavaScript expression that evaluates to the desired value. At its simplest, a binding may be a reference to another property. Take the following example, where the blue Rectangle's height is bound to the height of its parent:

```qml
Rectangle {
    width: 200; height: 200

    Rectangle {
        width: 100
        height: parent.height
        color: "blue"
    }
}
```

Whenever the height of the parent changes, the height of the rectangle automatically updates to the same value.

A binding can contain any valid JavaScript expression or statement. Bindings can access object properties, call methods, and use built-in JavaScript objects such as `Date` or `Math`. A bit more complex example would bind an objects `color` to the length of a text in another object.

```qml
color: myTextInput.text.length <= 10 ? "red" : "blue"
```

Here the object's color changes from blue to red when an other object's (with id `myTextInput`) text becomes longer than 10 characters.

It is important to note that while a bound property's value updates automatically, the binding will be removed if it's later assigned a static value by the JavaScript statement. This is a common source for troubles, especially for beginners! For example:

```qml
import QtQuick 2.0

Rectangle {
    width: 100
    height: width * 2

    focus: true
    Keys.onSpacePressed: {
        height = width * 3
    }
}
```

Here, the Rectangle initially ensures that its height is always twice its width. However, when the space key is pressed, the current value of width*3 will be assigned to height as a static value. After that, the height will remain fixed at this value, even if the width changes. The assignment of the static value removes the binding.

This can be desirable behavious in many cases. If the intention is to give the rectangle a fixed height and stop automatic updates, the code does exactly that. However, if the intention is to establish a new relationship between width and height, then the new binding expression must be wrapped in the `Qt.binding()` function instead:

```qml
import QtQuick 2.0

Rectangle {
    width: 100
    height: width * 2

    focus: true
    Keys.onSpacePressed: {
        height = Qt.binding(function() { return width * 3 })
    }
}
```
Now, after the space key is pressed, the rectangle's height will continue auto-updating to always be three times its width.


### QML Object tree

Syntactically, a block of QML code defines a tree of QML objects to be created. Objects are defined using object declarations that describe the type of object to be created as well as the attributes that are to be given to the object. Any object declaration can define child objects through nested object declarations. In this way, any object declaration implicitly declares an object tree that may contain any number of child objects.

For example, the Rectangle object declaration below includes a Gradient object declaration, which in turn contains two GradientStop declarations:

```qml
import QtQuick 2.0

Rectangle {
    width: 100
    height: 100

    gradient: Gradient {
        GradientStop { position: 0.0; color: "yellow" }
        GradientStop { position: 1.0; color: "green" }
    }
}
```

Note, however, that this is a parent-child relationship in the context of the QML object tree, not in the context of the visual scene. The concept of a parent-child relationship in a visual scene is provided by the `Item` type from the QtQuick module, which is the base type for most QML types, as most QML objects are intended to be visually rendered. We we will discuss parent-child relationship in visual scene in the next chapter. 
{: .note}
