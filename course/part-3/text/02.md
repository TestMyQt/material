# 3.02 QML Types and Properties

In the beginning of this chapter we're taking a general look into QML Types and the structure of the code. After that, we'll discuss QML object attributes and properties.

## QML Types and Structure

QML types are structures in the markup language, and they represent visual and non-visual parts. Non-visual QML types include functionality, such as states, transitions, models, paths, gradients and timers. 

All visual items in Qt Quick inherit from `Item`, but it's not itself visual. Using `Item` as the top-level QML object (as the root item of your component) will not produce a visual result. If you wish your top-level QML object to produce a visual result, you can use another type such as `Rectangle` or `Image` instead.

Note that even though `Item` is good as a root object for your own components, in the application's `main.qml` you'll usually want to use `Window` or one of its sub-types as the root. When creating a new QML project with the Qt Creator wizard, a `Window` object is created automatically to `main.qml`.

Although an `Item` object has no visual appearance, it defines all the attributes that are common across visual items, such as x and y position, width and height, anchoring and key focus handling. It supports layering and is usually used to group visual types. Use the `Item` to create opacity effects, such as when creating an invisible container to hold other components.

The `Item` type is useful for grouping several items under a single root visual item. For example:

```qml
import QtQuick 2.0

Item {
    id: root
    Text {
        text: "Hello There!"
        color: black
    }
    Image {
        id: imageOne
        x: 80
        width: 100
        height: 100
        source: "tile.png"
    }
    Image {
        id: imageTwo
        x: 190
        width: 100
        height: 100
        fillMode: Image.Tile
        source: "tile.png"
    }
}
```  

Please note that we are only using "magic numbers" in the examples for clarity's sake. In general, you should try to bind x, y, width and height to the parent, or another item, such as the root item of the component. How to do this will be explained shortly.

### QML Object tree

Syntactically, a block of QML code defines a tree of QML objects to be created. Objects are defined using object declarations that describe the type of object to be created as well as the attributes that are to be given to the object. Any object declaration can define child objects through nested object declarations. In this way, any object declaration implicitly declares an object tree that may contain any number of child objects.

For example, the Rectangle object declaration below includes a Gradient object declaration, which in turn contains two GradientStop declarations:

```qml
import QtQuick 2.0

Rectangle {
    width: 100
    height: 100

    gradient: Gradient {
        GradientStop { position: 0.0; color: "yellow" }
        GradientStop { position: 1.0; color: "green" }
    }
}
```

Note, however, that this is a parent-child relationship in the context of the QML object tree, not in the context of the visual scene. The concept of a parent-child relationship in a visual scene is provided by the `Item` type from the QtQuick module, which is the base type for most QML types, as most QML objects are intended to be visually rendered. We we will discuss visual parent-child relationship next. 

### Visual Parents and Children

The `QObject` parent-child relationship was discussed in Part 2. Now we will be taking a look at visual parents and children, as it's important to understand how the concept differs. An item's visual parent may not necessarily be the same as its object parent. The concept of the visual parent in Qt Quick is separate from, but related to, the concept of the object parent within the `QObject` parent hierarchy.

All QML objects have an object parent, which is determined by the object hierarchy in which the object is declared. When working with the `QtQuick` module, the `Item` type is the base type for all visual items provided by this module, and it provides the concept of an additional visual parent, as defined by an item's parent property. Every item has a visual parent; if an item's parent property value is `null`, the item will not be rendered in the scene.

Any object assigned to an item's data property becomes a child of the item within its `QObject` hierarchy, for memory management purposes. Additionally, if an object added to the data property is of the `Item` type, it is also assigned to the `Item::children` property and becomes a child of the item within the visual scene hierarchy. (Most Qt Quick hierarchy crawling algorithms, especially the rendering algorithms, only consider the visual parent hierarchy.)

For convenience, the `Item` data property is its default property. This means that any child item declared within an `Item` object without being assigned to a specific property is automatically assigned to the data property and becomes a child of the item as described above. So, the two code blocks below produce the same result, and you will almost always see the form shown below: 

```qml
import QtQuick 2.0

Item {
    width: 100; height: 100
    
    Rectangle { 
        width: 50;
        height: 50;
        color: "red"
    }
}
```

Rather than the explicit data assignment:

```qml
import QtQuick 2.0

Item {
    width: 100; height: 100

    data: [
        Rectangle {
            width: 50;
            height: 50;
            color: "red"
        }
    ]
}
```

An item's visual parent can be changed at any time by setting its parent property. Thus, an item's visual parent may not necessarily be the same as its object parent.

When an item becomes the child of another item:

* The child's parent refers to its parent item
* The parent's `children` and `childrenRect` properties take that child into account

Declaring an item as a child of another does not automatically mean that the child item will be appropriately positioned or sized to fit within its parent. Some QML types may have in-built behaviors that affect the positioning of child items — for example, a `Row` object automatically re-positions its children into a horizontal formation — but these are behaviors enforced by the types' own specific implementations. Additionally, a parent item will not automatically clip its children to visually contain them within the parent's visual bounds, unless its `clip` property is set to true.

## QML Object Attributes and Properties

Every QML object type has a defined set of attributes. Each instance of an object type is created with the set of attributes that have been defined for that object type.

A property is an attribute of an object that can be assigned a static value or bound to a dynamic JavaScript expression or even a code block. A property's value can be read by other objects according to property visibility scope rules. Generally it can also be modified by another object, unless a particular QML type has explicitly disallowed this for a specific property.

A property may be defined for a type in C++ by registering a `Q_PROPERTY` of a class which is then registered with the QML type system. We discussed these `QObject` properties in the last part. Alternatively, a custom or dynamic property of an object type may be defined in an object declaration in a QML document or component with the following syntax:

```qml
[default] property <propertyType> <propertyName>
```

In this way an object declaration may expose a particular value to outside objects or maintain some internal state more easily.

### Grouped Properties

In some cases properties contain a logical group of sub-property attributes. These sub-property attributes can be assigned to using either the dot notation or group notation.

For example, the Text type has a font group property. Below, the first Text object initializes its font values using dot notation, while the second uses group notation:

```qml
Text {
    //dot notation
    font.pixelSize: 12
    font.b: true
}

Text {
    //group notation
    font { pixelSize: 12; b: true }
}
```

### The id Property

The `id` property is a special property used to identify QML objects. It is used to create relationships between objects. The `id` property of an object allows other objects refer to it in regard to:

* Relative realignment and positioning
* To use its properties
* To change its properties (e.g. for animation)
* For re-use of common types (e.g. gradients, images).

For example:

```qml
Item { 
    width: 300; height: 115 
    Text { 
        id: title 
        x: 50; y: 25 
        text: "Qt Quick" 
        font { family: "Helvetica"; pointSize: parent.width * 0.1 } 
    } 
    
    Rectangle { 
        x: title.x; y: title.y + title.height - height; height: 5 
        width: title.width 
        color: "green" 
    }
} 
```

### Scope

Each QML component defines a logical scope. Each document has at least one root component, but can have other inline sub-components. The component scope is the union of the object ids within the component and the component's root object's properties. 

```qml
Item {
    property string title

    Text {
        id: titletype
        text: "<b>" + title + "</b>"
        font.pixelSize: 22
        anchors.top: parent.top
    }

    Text {
        text: titletype.text
        font.pixelSize: 18
        anchors.bottom: parent.bottom
    }
}
```

The example above shows a simple QML component that displays a rich text title string at the top, and a smaller copy of the same text at the bottom. The first `Text` type directly accesses the component's `title` property when forming the text to display. This makes it easy to distribute data throughout the component. The second `Text` type uses an id to access the first's text directly.

Component instances connect their component scopes together to form a scope hierarchy. Component instances can directly access the component scopes of their ancestors. This dynamic scoping allows us to do things like:

```qml
// TitlePage.qml
import QtQuick 2.0
Item {
    property string title

    TitleText {
        size: 22
        anchors.top: parent.top
    }

    TitleText {
        size: 18
        anchors.bottom: parent.bottom
    }
}

// TitleText.qml
import QtQuick 2.0
Text {
    property int size
    text: "<b>" + title + "</b>"
    font.pixelSize: size
}
```

Where the `TitleText` has access to `TitlePage`'s `title` property when used from within the `TitlePage` even though they exist in different files. Used somewhere else, the `title` property could resolve differently.

Some special attention needs to be given when considering the scope of attached properties. We'll talk about this with Attached Properties in general.

### Signal Handlers

Many QML types provide signals you can catch, for example `MouseArea` has signals `onPressed` and `onReleased`, among others.

QML types also provide built-in property change signals that are emitted whenever a property value changes. These signals take the form `on<Property>Changed` where <Property> is the name of the property with the first letter capitalized. These documentation of the types usually don't have these signals listed, because they are implicitly available throught the fact that the type has a property.

We'll talk about implementing your own custom signals in QML later in Part 3.

Signal handlers are a special sort of method attribute, where the method implementation is invoked by the QML engine whenever teh associated signal is emitted. For example:

```qml
TextInput {
    text: "Change this!"
    onTextChanged: console.log("Text has changed to:" text)
}
```

### Attached Properties and Attached Signal Handlers

Attached properties and attached signal handlers are mechanisms that enable objects to be annotated with extra properties or signal handlers that are otherwise unavailable to the object. In particular, they allow objects to access properties or signals that are specifically relevant to the individual object.

References to attached properties and handlers take the following syntax form:

```qml
<AttachingType>.<propertyName>
<AttachingType>.on<SignalName>
```

For example, the `ListView` type has an attached property `ListView.isCurrentItem` that is available to each delegate object in a `ListView`. This can be used by each individual delegate object to determine whether it is the currently selected item in the view:

```qml
import QtQuick 2.0

ListView {
    width: 240; height: 320
    model: 3
    delegate: Rectangle {
        width: 100; height: 30
        color: ListView.isCurrentItem ? "red" : "yellow"
    }
}
```

In this case, the name of the attaching type is `ListView` and the property in question is `isCurrentItem`, hence the attached property is referred to as `ListView.isCurrentItem`.

An attached signal handler is referred to in the same way. For example, the `Component.onCompleted` attached signal handler is commonly used to execute some JavaScript code when a component's creation process has been completed. In the example below, once the `ListModel` has been fully created, its `Component.onCompleted` signal handler will automatically be invoked to populate the model:

```qml
import QtQuick 2.0

ListView {
    width: 240; height: 320
    model: ListModel {
        id: listModel
        Component.onCompleted: {
            for (var i = 0; i < 10; i++)
                listModel.append({"Name": "Item " + i})
        }
    }
    delegate: Text { text: index }
}
```

Since the name of the attaching type is `Component` and that type has a completed signal, the attached signal handler is referred to as `Component.onCompleted`.

#### A Note About Scope

A common error is to assume that attached properties and signal handlers are directly accessible from the children of the object to which these attributes have been attached. This is not the case. The instance of the *attaching type* is only attached to specific objects, not to the object and all of its children.

For example, below is a modified version of the earlier example involving attached properties. This time, the delegate is an `Item` and the colored `Rectangle` is a child of that item:

```qml
import QtQuick 2.0

ListView {
    width: 240; height: 320
    model: 3
    delegate: Item {
        width: 100; height: 30

        Rectangle {
            width: 100; height: 30
            color: ListView.isCurrentItem ? "red" : "yellow"    // WRONG! This won't work.
        }
    }
}
```

This does not work as expected because `ListView.isCurrentItem` is attached only to the root delegate object, and not its children. Since the `Rectangle` is a child of the delegate, rather than being the delegate itself, it cannot access the `isCurrentItem` attached property as `ListView.isCurrentItem`. So instead, the rectangle should access `isCurrentItem` through the root delegate:

```qml
ListView {
    //....
    delegate: Item {
        id: delegateItem
        width: 100; height: 30

        Rectangle {
            width: 100; height: 30
            color: delegateItem.ListView.isCurrentItem ? "red" : "yellow"   // correct
        }
    }
}
```

Now `delegateItem.ListView.isCurrentItem` correctly refers to the `isCurrentItem` attached property of the delegate.

### Property Bindings

As we just mentioned, an object's property can be assigned a static value which stays constant until explicitly assigned a new value. However, to make the fullest use of QML and its built-in support for dynamic objecct behaviours, most QML objects use property bindings. Property bindings are a core feature of QML that lets developers specify relationships between different object properties. When property's dependencies change in value, the property is automatically updated according to the specified relationship.

Behind the scenes, the QML engine monitors the property's dependencies (that is, the variables in the binding expression). When a change is detected, the QML engine re-evaluates the binding expression and applies the new result to the property.

To create a property binding, a property is assigned a JavaScript expression that evaluates to the desired value. At its simplest, a binding may be a reference to another property. Take the following example, where the blue Rectangle's height is bound to the height of its parent:

```qml
Rectangle {
    width: 200; height: 200

    Rectangle {
        width: 100
        height: parent.height
        color: "blue"
    }
}
```

Whenever the height of the parent changes, the height of the rectangle automatically updates to the same value.

A binding can contain any valid JavaScript expression or statement. Bindings can access object properties, call methods, and use built-in JavaScript objects such as `Date` or `Math`. A bit more complex example would bind an objects `color` to the length of a text in another object.

```qml
color: myTextInput.text.length <= 10 ? "red" : "blue"
```

Here the object's color changes from blue to red when an other object's (with id `myTextInput`) text becomes longer than 10 characters.

It is important to note that while a bound property's value updates automatically, the binding will be removed if it's later assigned a static value by the JavaScript statement. This is a common source for troubles, especially for beginners! For example:

```qml
import QtQuick 2.0

Rectangle {
    width: 100
    height: width * 2

    focus: true
    Keys.onSpacePressed: {
        height = width * 3
    }
}
```

Here, the Rectangle initially ensures that its height is always twice its width. However, when the space key is pressed, the current value of width*3 will be assigned to height as a static value. After that, the height will remain fixed at this value, even if the width changes. The assignment of the static value removes the binding.

This can be desirable behavious in many cases. If the intention is to give the rectangle a fixed height and stop automatic updates, the code does exactly that. However, if the intention is to establish a new relationship between width and height, then the new binding expression must be wrapped in the `Qt.binding()` function instead:

```qml
import QtQuick 2.0

Rectangle {
    width: 100
    height: width * 2

    focus: true
    Keys.onSpacePressed: {
        height = Qt.binding(function() { return width * 3 })
    }
}
```
Now, after the space key is pressed, the rectangle's height will continue auto-updating to always be three times its width.

****