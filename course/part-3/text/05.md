# 3.05 - Mouse Handling

Qt can handle input form different input devices, such as touch screen, mouse, and so on. There are basically two different ways to handle input events. Area types, which handle input and Input Handlers, which can handle input from any number of devices. On this chapter we'll look at mouse handling with the `MouseArea` type. Next chapter will talk about Input Handlers in general.

## MouseArea

To enable mouse interaction with elements, `MouseArea` can be used. It's an invisible rectangular item that can capture mouse events and can be nested into an element like so:

```qml
Rectangle {
    width: 100; height: 100
    color: "green"
     
    MouseArea {
        anchors.fill: parent
        onClicked: parent.color = 'red'
    }
}
```

Now the logic of mouse handling is contained within the `MouseArea` item. This distinction is an important aspect of Qt Quick UIs, as this separates the input handling from visual presentations. This enables the visual items to be what ever the size they may be, but the input is only accepted within constraints defined in the input elements.

If multiple `MouseArea`s overlap, only the topmost in the visual hierarchy will receive the event by default. You can set `propagateComposedEvents` to `true` to allow the event to propagate further down the visual stacking order. See [documentation](http://doc.qt.io/qt-5/qml-qtquick-mousearea.html#propagateComposedEvents-prop) for further information and an example. In the next chapter we'll talk about `Input Handler`'s which arguably make overlaping areas more simple than `MouseArea`.

## Generic mouse events using the left mouse button

By default `MouseArea` reacts to the left mouse button and signals `onClicked`. To set `MouseArea` react to other types of buttons, set the `acceptedButtons` property with desired [`Qt::MouseButton`](http://doc.qt.io/qt-5/qt.html#MouseButton-enum) flag. Multiple flags can be combined with the `|` (or) operator. To access the currently pressed buttons, the `&` (and) operator can be used with the property `pressedButtons`.

In addition to the convenient `onClicked` handler, there are other handlers such as `onPressed`, `onWheel` or `onPositionChanged` that make it possible to handle more specific mouse events.

When emitted, many `MouseArea` signals pass in a `mouse` parameter that contains information about the mouse event, such as the position, button type and any key modifiers.

In this example we enable the left and right button of the mouse, and change the `Rectangle` color accordingly:

```qml
Rectangle {
    width: 100; height: 100
    color: "green"
     
    MouseArea {
        anchors.fill: parent
        acceptedButtons: Qt.LeftButton | Qt.RightButton
        onClicked: {
            if (mouse.button == Qt.RightButton) {
                parent.color = 'blue';
            } else {
                parent.color = 'red';
            }
        }
    }
}
```

## Visualizing the mouse hover

By default, `MouseArea` has handled mouse events when it has been clicked or buttons are held down, but it can also handle events when the mouse is currently hovering inside the area.

To enable hover event handling, the property `hoverEnabled` must be set to `true`. This affects the handlers `onEntered`, `onExited` and `onPositionChanged`. Handlers `onEntered` and `onExited` are signaled when the mouse enters or exits the area, and can be used to highlight or activate items. The `onPositionChanged` handler is signaled whenever the mouse moves inside the area. 

This example demonstrates text following the mouse pointer whenever the mouse enters the `MouseArea`:

```qml
Text {
    id: movingText
    text: "hover"
}
     
MouseArea {
    anchors.fill: parent
    hoverEnabled: true
    onPositionChanged: {
        movingText.x = mouse.x
        movingText.y = mouse.y
    } 
}
```

## Dragging items

In some UIs, it is beneficial to make some elements draggable, like volume sliders or images. `MouseArea` contains property `drag` that makes this possible.

`drag` itself has properties that are used to specify how the dragging is done.

1. `drag.target` specifies the id of the item to drag.
2. `drag.active` specifies if the target item is currently being dragged.
3. `drag.axis` specifies whether dragging can be done horizontally (`Drag.XAxis`), vertically (`Drag.YAxis`), or both (`Drag.XAndYAxis`)
4. `drag.minimum` and `drag.maximum`: how far the target can be dragged along the specified axes.

***

## Exercise - 05_MouseHandling

Simple exercise where we change the size of the text by clicking. File you need to edit is `MouseHandling.qml`.

## Exercise - ImageViewer

In this exercise we create a mouse area to scale and drag an image. File you need to edit is `ImageViewer.qml`.

***