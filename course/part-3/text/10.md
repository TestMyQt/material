# 3.10 - Custom Components

## A Bit More About Properties

Before getting into the actual subject of this chapter, Custom Components, let's expand a bit on the QML Property system that we introduced in chapter 3.02.

### Keyword default

When we introduced properties you saw the syntax 

```qml
[default] property <propertyType> <propertyName>
```

that's used to define a property in QML. However, in chapter 3.02 we didn't explain what the optional keyword `default` is used for. Let's talk about that now.

An object definition can have a single `default` property. A `default` property is the property to which a value is assigned if an object is declared within another object's definition without declaring it as a value for a particular property.

For example, say there is a file `MyLabel.qml` with a default property `someText`:

```qml
// MyLabel.qml
import QtQuick 2.0

Text {
    default property var someText

    text: "Hello, " + someText.text
}
```

The `someText` value could be assigned to in a `MyLabel` object definition, like this:

```qml
MyLabel {
    Text { text: "world!" }
}
```

This has exactly the same effect as the following:

```qml
MyLabel {
    someText: Text { text: "world!" }
}
```

However, since the someText property has been marked as the default property, it is not necessary to explicitly assign the `Text` object to this property.

You might have noticed that child objects can be added to any Item-based type without explicitly adding them to the children property. This is because the `default` property of `Item` is its data property, and any items added to this list for an `Item` are automatically added to its list of children.

### Keyword readonly

An object declaration may define a read-only property using the `readonly` keyword, with the following syntax:

```qml
readonly property <propertyType> <propertyName> : <initialValue>
```

Read-only properties must be assigned a value on initialization. After a read-only property is initialized, it no longer possible to give it a value, whether from imperative code or otherwise.

Note that a read-only property cannot also be a default property.

### Defining a Custom Signal

We talked about signal handlers in QML in chapter 3.02. What if we want to define our own signals? This can be done in C++, or as is more relevant to our current topic, in QML. 

The syntax for declaring a singal in QML is as follows: `signal <signalName>[([<type> <parameter name>[, ...]])]`

Attempting to declare two signals or methods with the same name in the same type block is an error. However, a new signal may reuse the name of an existing signal on the type. (This should be done with caution, as the existing signal may be hidden and become inaccessible.)

Here are three examples of signal declarations:

```qml
import QtQuick 2.0

Item {
    signal clicked
    signal hovered()
    signal actionPerformed(string action, var actionResult)
}
```

If the signal has no parameters, the "()" brackets are optional. If parameters are used, the parameter types must be declared, as for the string and var arguments for the `actionPerformed` signal above. The allowed parameter types are the same as those allowed in properties in general.

To emit a signal, invoke it as a method. Any relevant signal handlers will be invoked when the signal is emitted, and handlers can use the defined signal argument names to access the respective arguments.

### Connections Type

As we already saw in chapter 3.02, when connecting to signals in QML, the usual way is to create an `on<Signal>` handler that reacts when a signal is received.

However, it is not possible to connect to a signal in this way in some cases, such as when:

* Multiple connections to the same signal are required
* Creating connections outside the scope of the signal sender
* Connecting to targets not defined in QML

When any of these are needed, the `Connections` type can be used instead.

For example, the `Connections` object can be a child of some object other than the sender of the signal:

```qml
MouseArea {
    id: area
}
// ...
Connections {
    target: area
    onClicked: foo(parameters)
}
```

### Property Aliases

Property aliases are properties which hold a reference to another property. Unlike an ordinary property definition, which allocates a new, unique storage space for the property, a property alias connects the newly declared property (called the aliasing property) as a direct reference to an existing property (the aliased property).

A property alias declaration looks like an ordinary property definition, except that it requires the alias keyword instead of a property type, and the right-hand-side of the property declaration must be a valid alias reference:

```qml
[default] property alias <name>: <alias reference>
```

Unlike an ordinary property, an alias has the following restrictions:

* It can only refer to an object, or the property of an object, that is within the scope of the type within which the alias is declared.
* It cannot contain arbitrary JavaScript expressions
* It cannot refer to objects declared outside of the scope of its type.
* The alias reference is not optional, unlike the optional default value for an ordinary property; the alias reference must be provided when the alias is first declared.
* It cannot refer to grouped properties; the following code will not work:

```qml
property alias color: rectangle.border.color

Rectangle {
    id: rectangle
}
```

However, aliases to value type properties do work:

```qml
property alias rectX: object.rectProperty.x

Item {
    id: object
    property rect rectProperty
}
```


## QML Components

We have been previously using components in the material and exercises, but have not gone through how and why components are used in general. The definition of a component is it is an instantiable QML definition, a QML type. It is typically contained inside its own `.qml` file. For example, a `Button` component is defined in a file `Button.qml`. We can instantiate this `Button` component to create `Button` objects. A component may also be defined inside a `Component` item.

The `Button` definition may contain other components. The `Button` component could use a `Text` element, a `MouseArea` and other elements to implement the internal functions. This compounding of different components to form new components (and effectively new interfaces) is key in good, reusable UI components.

Let's walk through an example of a color picker for choosing the color of a text element. Our picker is currently made of four cells with different colors. A very naive approach is to write multiple `Item`s with `Rectangle` and `MouseArea` items inside the main application.

```qml
Rectangle {
    id: page
    width: 500
    height: 200
    color: "black"

    Text {
        id: helloText
        text: "Hello world!"
        y: 30
        anchors.horizontalCenter: page.horizontalCenter
    }

    Grid {
        id: colorPicker
        x: 4; anchors.bottom: page.bottom; anchors.bottomMargin: 4
        rows: 2; columns: 3; spacing: 3

        Item {
            width: 40
            height: 25

            Rectangle {
                id: rectangle
                color: "red"
                anchors.fill: parent
            }

            MouseArea {
                anchors.fill: parent
                onClicked: helloText.color = "red"
            }
        }          
        // Imagine more duplicate lines of Items with different color values defined...
    }
}
```

You might notice that we have lots of duplicate code here! Additionally, to add more colors, we need to define more elements with just the color values changed. To avoid writing the same code over and over again for each color, we can extract a `Cell` *component* from the duplicate code to `Cell.qml`.

Here is our component definition with `Rectangle` and `MouseArea` items extracted:

```qml
Item {
    id: container
    width: 40; height: 25

    Rectangle {
        id: rectangle
        color: "red"
        anchors.fill: parent
    }

    MouseArea {
        anchors.fill: parent
        onClicked: console.log("clicked?")
    }
}
```

Usually components are defined with the `Item` type as the root item. Now we have insatiable component, but currently it is a component without outside effects and it has a hardcoded color value. This is not very reusable, is it? How to make it reusable and interact with other items?

We cannot access the `text` property of our `Text` item `helloText` inside our component and we cannot access the `rectangle.color` property outside of the `Cell` component.
To do this, we need to expose an *interface* for other components to use. We can use the `property` keyword `alias` and the attribute `signal` to expose functionality.

```qml
Item {
    id: container
     
    property alias cellColor: rectangle.color
    signal clicked(color cellColor)
     
    width: 40; height: 25

    Rectangle {
        id: rectangle
        anchors.fill: parent
    }

    MouseArea {
        anchors.fill: parent
        onClicked: container.clicked(container.cellColor)
    }
}
```
 
Now we can write to the `rectangle.color` property outside from the component with the property `cellColor`, and we can install a *signal handler* for the `clicked` signal with the `onClicked` property:

```qml
Cell {
    cellColor: "red"
    onClicked: helloText.color = cellColor
}
```

Now we can easily add more colors with just the `Cell` definition:

```qml
Rectangle {
    id: page
    width: 500
    height: 200
    color: "black"

    Text {
        id: helloText
        text: "Hello world!"
        y: 30
        anchors.horizontalCenter: page.horizontalCenter
    }

    Grid {
        id: colorPicker
        x: 4; anchors.bottom: page.bottom; anchors.bottomMargin: 4
        rows: 2; columns: 2; spacing: 3

        Cell { cellColor: "red"; onClicked: helloText.color = cellColor }
        Cell { cellColor: "green"; onClicked: helloText.color = cellColor }
        Cell { cellColor: "blue"; onClicked: helloText.color = cellColor }
        Cell { cellColor: "yellow"; onClicked: helloText.color = cellColor }
    }
}
```

## Re-usable Components

To this point, we have been making standalone components, but now we are going to see how to integrate them in to a user facing application with navigation, layout and styling.

Components are typically added to a root [`Window`](https://doc.qt.io/qt-5/qml-qtquick-window-window.html) which acts as the top-level interface for user. But as we saw in the previous chapter, there also exists an extended [`ApplicationWindow`](https://doc.qt.io/qt-5/qml-qtquick-controls2-applicationwindow.html) which contains convenient methods to add frequently used UI items to the window. It also provides an interface to control the the window's properties, appearance and layout from within QML.

As previously discussed with making generic `Component`s, it is not preferable to reference the id of the application root item as this creates dependencies to other items. `ApplicationWindow` provides these generic properties to create an interface to itself without creating a dependency to a certain window id.

***

// Tehdään komponentti vaihe vaiheelt
// Kolme vaiheta
// miten exposataan komponentin sisältä property/alias property
// miten lisätään signaali ja JS-metodi, joka voi olla ihan triviaali
// Miten ankkuroida komponentti, tehdä siitä skaalautuva
// Kattokaapa smeidän sisäisestä matskusta se ImageViewerin pari ekaa vaihetta. En tiedä tekeekö tuo alla nuo kaikki vaiheet
// Voisi olla triviaali animaatiokin, niin kuin mun MessageBox:ssa. Behaviour-tyypillä. Ei vaadi edes omaa teoriaa. 
## Exercise - CustomSignals

Your task is to implement a simple checkbox component with a couple of signals and some logic. The type you will be working with is in `CustomCheckbox.qml`

Make some sort of visual change when checking/unchecking the checkbox, change picture or text

Create custom signal 'checked' that will emit:
- true when the checkbox is checked
- false when unchecked

Expose property 'checkMax' that will be used as the inclusive upper bound of the number checks
- Disable the checkbox after it has been checked the defined number of times, meaning that the checkbox should not allow any further input from the user
- If checkCount is not defined, allow infinite checks

Create a signal named 'disabled' that will emit after the checkbox has been disabled

- Use the 'state' property of the parent 'checkBox'
- The states are 'checked', 'unchecked' and "disabled"

Optional extra: you can use these states to animate the visual change of the checkbox!

***