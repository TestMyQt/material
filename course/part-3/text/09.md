# 3.09 - Qt Quick Controls

// Muista: Lisää esimerkkejä Controls kohtaan

Qt Quick Controls provide ready-made UI controls, which allows you to work faster because you don't have to make everything from scratch. For example, `ApplicationWindow` provides a `QQuickWindow` with header, footer, menu bar, and popups. Window can contain a layout of views, containers, and controls.

Note that when we talk about Qt Quick Controls on this course, we are always referring to Qt Quick Controls 2. If you browse the Qt documentation, you might find out about Qt Quick Controls 1 as well. They are going to be deprecated in the future, and you should avoid using them.

## Getting Started

To use Qt Quick Controls you need to import `QtQuick.Controls` in your .qml file. For example:

```qml
// main.qml
import QtQuick 2.6
import QtQuick.Controls 2.4

ApplicationWindow {
    title: "My Application"
    width: 640
    height: 480
    visible: true

    Button {
        text: "Push Me"
        anchors.centerIn: parent
    }
}
```

You should use `ApplicationWindow` as the root item in your application and launch it by using `QQmlApplicationEngine` in C++. This ensures that you can control top level window properties from QML. For example: 

```cpp
// main.cpp
#include <QGuiApplication>
#include <QQmlApplicationEngine>

int main(int argc, char *argv[])
{
    QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
    QGuiApplication app(argc, argv);
    QQmlApplicationEngine engine;
    engine.load(QUrl(QStringLiteral("qrc:/main.qml")));
    return app.exec();
}
```

Note that if you built Qt from source, make sure Qt Graphical Effects module is also built, as Qt Quick Controls 2 requires it.

## Application Window

`ApplicationWindow` is a `Window` which makes it convenient to add a menu bar, header and footer item to the window. As we already stated, you should usually use `ApplicationWindow` as the root item in your application. 

```qml
import QtQuick 2.11
import QtQuick.Controls 2.4

ApplicationWindow {
    visible: true
    width: 640
    height: 480
    title: qsTr("Application Window")
    minimumHeight: 300
    minimumWidth: 330

    menuBar: MenuBar {
        Menu {
            title: qsTr("File")
            MenuItem { text: qsTr("Open") }
            MenuItem { text: qsTr("Close") }
        }
    }

    header: Label {
        horizontalAlignment: Text.AlignHCenter
        height: 40
        font.pixelSize: 70
        minimumPixelSize: 8
        fontSizeMode: Text.Fit
        text: qsTr("Header")
        background: Rectangle {
            anchors.fill: parent
            border { width: 2; color: "black" }
            color: "lightgreen"
        }
    }

    footer:
        Label {
            horizontalAlignment: Text.AlignHCenter
            text: qsTr("Footer")
            font.pixelSize: 24
        }
}
```
![Application Window]({{ "/assets/images/part-3/application_window.png" | absolute_url }})

In this short example we define a menu bar, a header, and a footer. As you can see this can be done very easily by using Qt Quick Controls. We suggest you copy the example to a fresh QML project in the Qt Creator and run it. Try to play around with some of the parameters to see what happens. 

## Views

With Quick Controls making fluid UI's is easy. It provides several different views, like `ScrollView`, `SwipeView`, and `StackView`. We'll take a look at `StackView` little bit more closely here. Feel free to browse the documentation and play around with the other views to see how they behave.

`StackView` can be used with a set of inter-linked information pages. Views are pushed onto the stack when going forward, and popped out when going back.

The following example demonstrates a simple use case, where the mainView is pushed onto and popped out of the stack on relevant button click:

```qml
import QtQuick 2.11
import QtQuick.Controls 2.4

ApplicationWindow {
    title: qsTr("StackView")
    width: 400
    height: 280
    visible: true

    StackView {
        id: stack
        initialItem: mainView
        anchors.fill: parent
    }

    Component {
        id: mainView

        Column {
            spacing: 10

            Button {
                text: "Push"
                onClicked: stack.push(mainView)
            }
            Button {
                text: "Pop"
                enabled: stack.depth > 1
                onClicked: stack.pop()

            }
            Text {
                font.pixelSize: 30
                text: stack.depth
            }
        }
    }
}
```

Using `StackView` in an application is as simple as adding it as a child to a Window. The stack is usually anchored to the edges of the window, except at the top or bottom where it might be anchored to a status bar, or some other similar UI component. The stack can then be used by invoking its navigation methods. The first item to show in the `StackView` is the one that was assigned to `initialItem`, or the topmost item if `initialItem` is not set.

`StackView` supports three primary navigation operations: `push()`, `pop()`, and `replace()`. These correspond to classic stack operations where "push" adds an item to the top of a stack, "pop" removes the top item from the stack, and "replace" is like a pop followed by a push, which replaces the topmost item with the new item. The topmost item in the stack corresponds to the one that is currently visible on screen.

### Transitions

For each push or pop operation, different transition animations are applied to entering and exiting items. These animations define how the entering item should animate in, and the exiting item should animate out. The animations can be customized by assigning different Transitions for the `pushEnter`, `pushExit`, `popEnter`, `popExit`, `replaceEnter`, and `replaceExit` properties of `StackView`.

Note that the transition animations affect each others' transitional behavior. Customizing the animation for one and leaving the other may give unexpected results.

The following example defines a simple fade transition for push and pop operations:

```qml
StackView {
    id: stackview
    anchors.fill: parent

    pushEnter: Transition {
        PropertyAnimation {
            property: "opacity"
            from: 0
            to:1
            duration: 200
        }
    }
    pushExit: Transition {
        PropertyAnimation {
            property: "opacity"
            from: 1
            to:0
            duration: 200
        }
    }
    popEnter: Transition {
        PropertyAnimation {
            property: "opacity"
            from: 0
            to:1
            duration: 200
        }
    }
    popExit: Transition {
        PropertyAnimation {
            property: "opacity"
            from: 1
            to:0
            duration: 200
        }
    }
}
```

Note: Using anchors on the items added to a `StackView` is not supported. Typically push, pop, and replace transitions animate the position, which is not possible when anchors are applied. Notice that this only applies to the root of the item. Using anchors for its children works as expected.

## Controls

Qt Quick Controls offers a large selection of controls that can be used to build complete interfaces in Qt Quick. These include different button-like controls like `Button` and `Switch`, input controls like `TextArea` and `Slider`, and variety of other 

Simple controls like `Button`, `Slider`, etc. are rather trivial to use, for example you'd define a slider from 0 to 100 with:

```qml
Slider {
    id: percentage
    from: 0
    to: 100
    value: 20
}
```
![Slider]({{ "/assets/images/part-3/slider.png" | absolute_url }})

// Drawer and/or ComboBox ?

### Container Controls

`Container` type supports adding, inserting, moving, and removing items. You can use a ready visual implementation of `Container` like `SwipeView`. To implement a custom container, the most important part of the API is `contentModel` which provides the contained items in a way that it can be used as a delegate model for item views and repeaters. For example:

```qml
Container {
    id: container

    contentItem: ListView {
        model: container.contentModel
        snapMode: ListView.SnapOneItem
        orientation: ListView.Horizontal
    }

    Text {
        text: "Page 1"
        width: container.width
        height: container.height
    }

    Text {
        text: "Page 2"
        width: container.width
        height: container.height
    }
}
```

We'll discuss data models for visualizing data in Part 4. 

## Styling

Qt Quick Controls come with with a selection of styles. Beyond the default style there is Fusion, Material, Imagine, and Universal styles. You can see them here in [the documentation](https://doc.qt.io/qt-5/qtquickcontrols2-styles.html).

In order to run an application with a specific style, either configure the style using `QQuickStyle` in C++, pass a command line argument, or set an environment variable. Alternatively, the preferred style and style-specific attributes can be specified in a configuration file.

The priority of these approaches follows the order they are listed above, from highest to lowest. That is, using `QQuickStyle` to set the style will always take priority over using the command line argument, for example.

* In C++ you set `QQuickStyle` with `QQuickStyle::setStyle("Material");`

* Passing a `-style` command line argument is the convenient way to test different styles. `./app -style material`

* Setting the `QT_QUICK_CONTROLS_STYLE` environment variable can be used to set a system-wide style preference. `QT_QUICK_CONTROLS_STYLE=universal ./app`

* Configuration file: Qt Quick Controls 2 support a special configuration file, `:/qtquickcontrols2.conf`, that is built into an application's resources. The configuration file can specify the preferred style (may be overridden by either of the methods described earlier) and certain style-specific attributes.

```qml
[Controls]
Style=Material
```

The configuration file can be used to define certain other things too, see [the documentation](https://doc.qt.io/qt-5/qtquickcontrols2-configuration.html) for further details.

***