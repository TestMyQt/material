# 3.11 - Shape

As the final subject of Part 3, let's look at the `Shape` type, which is used to render arbitary shapes (as opposed to types like `Rectangle` that we already saw). `Shape` renders a path either by generating geometry via `QPainterPath` and manual triangulation or by using a GPU vendor extension.

This approach is different from rendering shapes via `QQuickPaintedItem` or the 2D Canvas because the path never gets rasterized in software. Therefore `Shape` is suitable for creating shapes spreading over larger areas of the screen, avoiding the performance penalty for texture uploads or framebuffer blits. In addition, the declarative API allows manipulating, binding to, and even animating the path element properties like starting and ending position, the control points, and so on.

Variety of different paths are supported, e.g. line, ellipse, arc, quadratic curve, etc. See [Path](https://doc.qt.io/qt-5.11/qml-qtquick-path.html) documentation for a list of all available path elements. 

Like `Item`, `Shape` also allows any visual or non-visual objects to be declared as children. `ShapePath` objects are handled specially. This is useful since it allows adding visual items, like `Rectangle` or `Image`, and non-visual objects, like `Timer` directly as children of `Shape`.

When using `Shape`, it is important to be aware of potential performance implications (you don't need to memorize or even fully understand this list, but it's nice to know):

* When the application is running with the generic, triangulation-based `Shape` implementation, the geometry generation happens entirely on the CPU. This is potentially expensive. Changing the set of path elements, changing the properties of these elements, or changing certain properties of the `Shape` itself all lead to retriangulation of the affected paths on every change. Therefore, applying animation to such properties can affect performance on less powerful systems.
* However, the data-driven, declarative nature of the `Shape` API often means better cacheability for the underlying CPU and GPU resources. A property change in one `ShapePath` will only lead to reprocessing the affected `ShapePath`, leaving other parts of the `Shape` unchanged. Therefore, a frequently changing property can still result in a lower overall system load than with imperative painting approaches (for example, `QPainter`).
* If animating properties other than stroke and fill colors is a must, it is recommended to target systems providing `GL_NV_path_rendering` where the cost of property changes is smaller.
* At the same time, attention must be paid to the number of `Shape` elements in the scene, in particular when using this special accelerated approach for `GL_NV_path_rendering`. The way such a `Shape` item is represented in the scene graph is different from an ordinary geometry-based item, and incurs a certain cost when it comes to OpenGL state changes.
* As a general rule, scenes should avoid using separate `Shape` items when it is not absolutely necessary. Prefer using one `Shape` item with multiple `ShapePath` elements over multiple `Shape` items. Scenes that cannot avoid using a large number of individual `Shape` items should consider setting `Shape.vendorExtensionsEnabled` to false.

Now, let's look at an example:

```qml
import QtQuick 2.9
import QtQuick.Window 2.2
import QtQuick.Shapes 1.0

Window {
    visible: true
    width: 640
    height: 480
    title: qsTr("Shapes")

    Shape {
        id: shape
        anchors.fill: parent
        ShapePath {
            strokeWidth: 10
            strokeColor: "black"
            fillGradient: RadialGradient {
                centerX: shape.width / 2; centerY: shape.height / 2
                centerRadius: shape.width * 0.1
                focalX: centerX; focalY: centerY
                spread: ShapeGradient.RepeatSpread
                GradientStop { position: 0; color: "yellow" }
                GradientStop { position: 1; color: "blue" }
            }
            strokeStyle: ShapePath.SolidLine
            startX: shape.width * 0.3; startY: shape.height * 0.1
            PathLine { x: shape.width * 0.7; y: shape.height * 0.1 }
            PathLine { x: shape.width * 0.9; y: shape.height * 0.3 }
            PathLine { x: shape.width * 0.9; y: shape.height * 0.7 }
            PathLine { x: shape.width * 0.7; y: shape.height * 0.9 }
            PathLine { x: shape.width * 0.3; y: shape.height * 0.9 }
            PathLine { x: shape.width * 0.1; y: shape.height * 0.7 }
            PathLine { x: shape.width * 0.1; y: shape.height * 0.3 }
            PathLine { x: shape.width * 0.3; y: shape.height * 0.1 }
        }
    }
}

```

![Shape]({{ "/assets/images/part-3/shape.png" | absolute_url }})

What's happening here is that in `ShapePath` we've defined the shape with straight lines, and fill it with a radial gradient that repeats. If you have trouble following the code (and even if you don't), go ahead and play around with it a bit! Try commenting out some of the `PathLine`s and see what happens. Change the gradient's `spread` property to `ShapeGradient.ReflectSpread` and to see what that looks like.