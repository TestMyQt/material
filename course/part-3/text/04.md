# 3.04 - Text Input and Key Handling

## Focus

In order for an object to receive keyboard events, it needs to have active focus. In this chapter we're focusing on text input, but any item can have focus and thus respond to input, let it be from the keyboard or somewhere else. 

In the most simple case, where we only have one Item in need of focus, this can be done by simply setting the `focus` property to true. For example:

```qml
Rectangle {
    color: "lightsteelblue"; width: 240; height: 25
    Text { id: myText }
    Item {
        id: keyHandler
        focus: true
        Keys.onPressed: {
            if (event.key == Qt.Key_A)
                myText.text = 'Key A was pressed'
            else
                myText.text = 'Key other than A was pressed'
        }
    }
}
```

However, setting the `focus` property doesn't itself quarantee that the object will have active focus, but that it can receive it. When the application grows, there will most certainly be multiple objects wanting active focus, and just setting the `focus` property is no longer enough. If there are multiple objects requesting focus it will be granted to the last one created.

There are a few ways to solve this probelm. In the case of `TextInput`, for example, the property `activeFocusOnPress` is set to true by default, which allows it to receive active focus when it's clicked. (Note that if `TextInput` has no text, there's no way to click it, unless it has a width or by using anchors.)

Another way to get focus would be to explicitly pass it between objects. In this example the `nameField` item defines `KeyNavigation.tab`, which results to pressing Tab moving the focus to the `addressField` item

```qml
TextInput { 
    id: nameField
    focus: true 
    KeyNavigation.tab: addressField 
}
```

And the `addressField` item defines `KeyNavigation.backtab`, which results to pressing Shift+Tab moving focus to the `nameField` item.

```qml
TextInput { 
    id: addressField
    KeyNavigation.backtab: nameField 
}
```

Third way is by using a special type called `FocusScope`.

### FocusScope

Focus scopes assist in keyboard focus handling when building reusable QML components.

Within each focus scope one object may have `Item::focus` set to true. If more than one Item has the focus property set, the last type to set the focus will have the focus and the others are unset, similar to when there are no focus scopes. When a focus scope receives active focus, the contained type with focus set (if any) also gets the active focus.

Let's look at an example. The code creates two MyClickableWidget instances:

```qml
Rectangle {
    id: window

    color: "white"; width: 240; height: 150

    Column {
        anchors.centerIn: parent; spacing: 15

        MyClickableWidget {
            focus: true  // Initial focus here
            color: "lightblue"
        }
        MyClickableWidget {
            color: "palegreen"
        }
    }

}
```
The inital focus is set to the first `MyClickableWidget` created. If `MyClickableObject` was created without `FocusScope`, this initial focus would not be granted, because the `Rectangle` within `MyClickableWidget` sets its focus to true, and eventually the focus would go to the last object created, in this case the second instance of `MyClickableWidget`.

```qml
// MyClickableWidget
FocusScope {

    id: scope

    // FocusScope needs to bind to visual properties of the children
    property alias color: rectangle.color
    x: rectangle.x; y: rectangle.y
    width: rectangle.width; height: rectangle.height

    Rectangle {
        id: rectangle
        anchors.centerIn: parent
        color: "lightsteelblue"; width: 175; height: 25; radius: 10; antialiasing: true
        Text { id: label; anchors.centerIn: parent }
        focus: true
        Keys.onPressed: {
            if (event.key == Qt.Key_A)
                label.text = 'Key A was pressed'
            else if (event.key == Qt.Key_B)
                label.text = 'Key B was pressed'
            else if (event.key == Qt.Key_C)
                label.text = 'Key C was pressed'
        }
    }
    MouseArea { anchors.fill: parent; onClicked: { scope.focus = true } }
}
```
The `Rectangle` is created inside the `FocusScope`, and a `MouseArea` (discussed in next chapter) is created to give focus to the last rectangle clicked.

Note that, since the `FocusScope` type is not a visual type, the properties of its children need to be exposed to the parent item of the `FocusScope`. Layouts and positioning types will use these visual and styling properties to create the layout. In our example, the `Column` type cannot display the two widgets properly because the `FocusScope` lacks visual properties of its own. The `MyClickableWidget` component directly binds to the rectangle properties to allow the `Column` type to create the layout containing the children of the `FocusScope`.


## Text Input

In QML, there are two types that display text input `TextEdit` and `TextInput`. `TextEdit` displays multiple lines of input, where as `TextInput` displays a single line of text input.

In addition Qt Quick Controls provide similar `TextField` and `TextArea` so there's no need to create each and every component from scratch.

### TextInput

The `TextInput` type displays a single line of editable plain text.

`TextInput` is used to accept a line of text input. Input constraints can be placed on a `TextInput` item (for example, through a validator or inputMask), and setting `echoMode` to an appropriate value enables `TextInput` to be used for a password input field.

For example:

```qml
TextInput {
    id: hexNumber
    validator: RegExpValidator { regExp: /[0-9A-F]+/ }
}
```
A regular expression validator is set to only allow inputs that are hexadecimal (0-9, A-F).

```qml
TextInput {
    id: ipAddress
    inputMask: "000.000.000.000"
}
```
Input mask is set to allow IPv4 addresses.

### TextEdit

The `TextEdit` item displays a block of editable, formatted text.

It can display both plain and rich text. For example:

```qml
TextEdit {
    width: 240
    text: "<b>Hello</b> <i>World!</i>"
    font.family: "Helvetica"
    font.pointSize: 20
    color: "blue"
    focus: true
}
```

Note that the `TextEdit` does not implement scrolling, following the cursor, or other behaviors specific to a look-and-feel. For example, to add flickable scrolling that follows the cursor:

```qml
Flickable {
    id: flick

    width: 300; height: 200;
    contentWidth: edit.paintedWidth
    contentHeight: edit.paintedHeight
    clip: true
    
    function ensureVisible(r) {
        if (contentX >= r.x)
            contentX = r.x;
        else if (contentX+width <= r.x+r.width)
            contentX = r.x+r.width-width;
        if (contentY >= r.y)
            contentY = r.y;
        else if (contentY+height <= r.y+r.height)
            contentY = r.y+r.height-height;
    }

    TextEdit {
        id: edit
        width: flick.width
        focus: true
        wrapMode: TextEdit.Wrap
        onCursorRectangleChanged: flick.ensureVisible(cursorRectangle)
    }
}
```

A particular look-and-feel might use smooth scrolling (eg. using `SmoothedAnimation`), might have a visible scrollbar, or a scrollbar that fades in to show location, etc.

Clipboard support is provided by the `cut()`, `copy()`, and `paste()` functions, and the selection can be handled in a traditional "mouse" mechanism by setting `selectByMouse`, or handled completely from QML by manipulating `selectionStart` and `selectionEnd`, or using `selectAll()` or `selectWord()`.

You can translate between cursor positions (characters from the start of the document) and pixel points using `positionAt()` and `positionToRectangle()`.

## Keys

All visual primitives support key handling via the `Keys` attached property. Keys can be handled via the `onPressed` and `onReleased` signal properties.

The signal properties have a `KeyEvent` parameter, a named event which contains details of the event. For example, you can access the key pressed from `event.key` and modifier pressed from `event.modifiers`.

If a key is handled `event.accepted` should be set to `true` to prevent the event from propagating up the item hierarchy.

The `Keys` attached property can be configured to handle key events before or after the item it is attached to. This makes it possible to intercept events in order to override an item's default behavior, or act as a fallback for keys not handled by the item.

In the following example we use the general `onPressed` handler to test if a 'Y' key is being pressed with Ctrl modifier:

```qml
Item {
    anchors.fill: parent
    focus: true
    Keys.onPressed: {
        if ((event.key == Qt.Key_Y) && (event.modifiers & Qt.ControlModifier)) {
            console.log("Y pressed with Ctrl");
            event.accepted = true;
        }
    }
}
```

Some keys may alternatively be handled via specific signal properties, for example `onSelectPressed`. These handlers automatically set `event.accepted` to `true`.

```qml
Item {
    anchors.fill: parent
    focus: true
    Keys.onLeftPressed: console.log("move left")
}
```

## Key handling priorities

// T채채 alkaa jotenkin keskelt채 aihetta. Aloittakaa ilman If:i채. The default processing order...

The default priority is `Keys.BeforeItem`, where the order of key event processing is:

1. Items specified in `forwardTo`
2. specific key handlers, e.g. `onReturnPressed`
3. `onPressed`, `onReleased` handlers
4. Item specific key handling, e.g. `TextInput` key handling
5. parent item

If priority is `Keys.AfterItem` the order of key event processing is:

1. Item specific key handling, e.g. `TextInput` key handling
2. Items specified in `forwardTo`
3. specific key handlers, e.g. `onReturnPressed`
4. `onPressed`, `onReleased` handlers
5. parent item

If the event is accepted during any of the above steps, key propagation stops.

## Key Handling Overview

When the user presses or releases a key, the following occurs:

1. Qt receives the key action and generates a key event.
2. If a `QQuickWindow` is the active window, the key event is delivered to it.
3. The key event is delivered by the scene to the `Item` with active focus. If no item has active focus, the key event is ignored.
4. If the `QQuickItem` with active focus accepts the key event, propagation stops. Otherwise the event is sent to the Item's parent until the event is accepted, or the root item is reached.

In some cases you might even want to catch these events in Qt, before they get delivered to the QML engine. However, we won't go into C++ and QML integration yet in this part of the course.

If the `Rectangle` type in the following example has active focus and the A key is pressed, the event will not be propagated further. Upon pressing the B key, the event will propagate to the root item and thus be ignored.

```qml
Rectangle {
    width: 100; height: 100
    focus: true
    Keys.onPressed: {
        if (event.key == Qt.Key_A) {
            console.log('Key A was pressed');
             event.accepted = true;
        }
    }
}
```
     
***

// T채st채kin sais kolme
// Perus key handling ja modifierit. Pit채채 vaikka vaan tulostaa consoleen, mit채 tulee sis채채n
// Focus handling jollain nabilla eli se KeyNavigation
// Focus Scope
## Exercise - KeyHandling

Create a blue 50x50px Rectangle at the starting position x=175 and y=125 that moves 10px to the corresponding direction when arrow keys are pressed. 

Then implement functionality so that the rectangle changes color between blue and red when the Tab key is pressed.

You need to expose 3 properties. The color as boxColor and the x/y coordinates as xCoord and yCoord, respectively.

***
