# 3.04 - Text Input and Key Handling

// Explain Focus here (better)

// Aloittaisin Itemistä. Milloin Item voi vastaanottaa napin painalluksia. Pitääkö sen olla visible, entö active. Mitä tarkoittaa focus, entä activeFocus

## Focus

// Vähän laajentaisin TextInputin ulkopuolelle. The keyboard focus is given to an item, if there are no ... Focuksenhan voi saada vaikka Rectangle ja sekin on hyvä mainita, että mikä tahansa Item voi sen saada. Sit just noi, mistä se focus voi tulla. *J: Siirsin tämän heti kappaleen alkuun, muokkasin geneerisemmäksi. Esimerkeissä tulee esiin TextInput ja Keys.something ennen kuin ne on esitely, mutta se ei mielestäni haittaa koska ajatus on selkeä ja ne esitellään myöhemmin samassa chapterissa.*

In order for an object to receive keyboard events, it needs to have active focus. In this chapter we're focusing on text input, but any item can have focus and thus respond to input, let it be from the keyboard or somewhere else. 

In the most simple case, where we only have one Item in need of focus, this can be done by simply setting the `focus` property to true. For example:

```qml
Rectangle {
    color: "lightsteelblue"; width: 240; height: 25
    Text { id: myText }
    Item {
        id: keyHandler
        focus: true
        Keys.onPressed: {
            if (event.key == Qt.Key_A)
                myText.text = 'Key A was pressed'
            else
                myText.text = 'Key other than A was pressed'
        }
    }
}
```

However, setting the `focus` property doesn't itself quarantee that the object will have active focus, but that it can receive it. When the application grows, there will most certainly be multiple objects wanting active focus, and just setting the `focus` property is no longer enough. If there are multiple objects requesting focus it will be granted to the last one created.

There are a few ways to solve this probelm. In the case of `TextInput`, for example, the property `activeFocusOnPress` is set to true by default, which allows it to receive active focus when it's clicked. (Note that if `TextInput` has no text, there's no way to click it, unless it has a width or by using anchors.)

// *J: Tämän esimerkin voi mielestäni poistaa (kommentoin sen nyt ulos)*

<!-- In UI:s with just one `TextInput` focus is assigned automatically. In UI:s with more than one `TextInput` focus needs to be changed via clicking.  
What happens if a `TextInput` has no text? 
In that case there is no way to click on it, unless it has a width or uses anchors.
Focus is assigned trough setting the `focus` property.

```qml
TextInput { 
    id: upperTextInput
    anchors.left: parent.left 
    anchors.right: parent.right 
    text: "Field 1"; font.pixelSize: 32 
    color: focus ? "black" : "gray" 
    text: qsTr("Field") } 
TextInput { 
    anchors.left: parent.left
    anchors.top: upperTextInput.bottom
    anchors.right: parent.right 
    text: qsTr("Field 2"); font.pixelSize: 32 
    color: focus ? "black" : "gray"
}
``` -->
// Anoter way to get the focus...

Another way to get focus would be to explicitly pass it between objects. In this example the `nameField` item defines `KeyNavigation.tab`, which results to pressing Tab moving the focus to the `addressField` item

```qml
TextInput { 
    id: nameField
    focus: true 
    KeyNavigation.tab: addressField 
}
```

And the `addressField` item defines `KeyNavigation.backtab`, which results to pressing Shift+Tab moving focus to the `nameField` item.

```qml
TextInput { 
    id: addressField
    KeyNavigation.backtab: nameField 
}
```

// Harjoitus. Siellä mun demoissa on joku demo, missä suorakulmion väri vaihtuu, kun sillä on focus. Vois olla suorakulmioita ja tekstisyöttökenttiä

Third way is by using a special type called `FocusScope`.

### FocusScope

Focus scopes assist in keyboard focus handling when building reusable QML components.

// Hmm, en ymmärrä alla olevaa lausetta. Normaalisti viimeiseksi luotu olio saa fokuksen, mutta alla siis viimeisenä sitä pyytävä
// Harjoitus. tästäkin löytyy yksinerktainen demo, jossa mulla oli niitä TextInpoutteja. Vois olla Gridi noita input komponentteja ja pitäis määritellä, että joku niistä saisi sen fouksen *J: Laajensin tätä osiota aika paljon, toivottavasti se on selkeämpi esimerkin kera*

Within each focus scope one object may have `Item::focus` set to true. If more than one Item has the focus property set, the last type to set the focus will have the focus and the others are unset, similar to when there are no focus scopes. When a focus scope receives active focus, the contained type with focus set (if any) also gets the active focus.

Let's look at an example. The code creates two MyClickableWidget instances:

```qml
Rectangle {
    id: window

    color: "white"; width: 240; height: 150

    Column {
        anchors.centerIn: parent; spacing: 15

        MyClickableWidget {
            focus: true  // Initial focus here
            color: "lightblue"
        }
        MyClickableWidget {
            color: "palegreen"
        }
    }

}
```
The inital focus is set to the first `MyClickableWidget` created. If `MyClickableObject` was created without `FocusScope`, this initial focus would not be granted, because the `Rectangle` within `MyClickableWidget` sets its focus to true, and eventually the focus would go to the last object created, in this case the second instance of `MyClickableWidget`.

```qml
// MyClickableWidget
FocusScope {

    id: scope

    // FocusScope needs to bind to visual properties of the children
    property alias color: rectangle.color
    x: rectangle.x; y: rectangle.y
    width: rectangle.width; height: rectangle.height

    Rectangle {
        id: rectangle
        anchors.centerIn: parent
        color: "lightsteelblue"; width: 175; height: 25; radius: 10; antialiasing: true
        Text { id: label; anchors.centerIn: parent }
        focus: true
        Keys.onPressed: {
            if (event.key == Qt.Key_A)
                label.text = 'Key A was pressed'
            else if (event.key == Qt.Key_B)
                label.text = 'Key B was pressed'
            else if (event.key == Qt.Key_C)
                label.text = 'Key C was pressed'
        }
    }
    MouseArea { anchors.fill: parent; onClicked: { scope.focus = true } }
}
```
The `Rectangle` is created inside the `FocusScope`, and a `MouseArea` (discussed in next chapter) is created to give focus to the last rectangle clicked.

Note that, since the `FocusScope` type is not a visual type, the properties of its children need to be exposed to the parent item of the `FocusScope`. Layouts and positioning types will use these visual and styling properties to create the layout. In our example, the `Column` type cannot display the two widgets properly because the `FocusScope` lacks visual properties of its own. The `MyClickableWidget` component directly binds to the rectangle properties to allow the `Column` type to create the layout containing the children of the `FocusScope`.


## Text Input

// Laittauisin. In QML, teher are .... In addition, Qt Quick Controls provide ... so there's no need to create each and every component from the scratch *J: Mulle on edelleen vähän auki missä tilanteissa halutaan käyttää QML typejä ja missä näitä Controlseja.*

In QML, there are two types that display text input `TextEdit` and `TextInput`. `TextEdit` displays multiple lines of input, where as `TextInput` displays a single line of text input.

In addition Qt Quick Controls provide similar `TextField` and `TextArea` so there's no need to create each and every component from scratch.

### TextInput

The `TextInput` type displays a single line of editable plain text.

`TextInput` is used to accept a line of text input. Input constraints can be placed on a `TextInput` item (for example, through a validator or inputMask), and setting `echoMode` to an appropriate value enables `TextInput` to be used for a password input field.

For example:

```qml
TextInput {
    id: hexNumber
    validator: RegExpValidator { regExp: /[0-9A-F]+/ }
}
```
A regular expression validator is set to only allow inputs that are hexadecimal (0-9, A-F).

```qml
TextInput {
    id: ipAddress
    inputMask: "000.000.000.000"
}
```
Input mask is set to allow IPv4 addresses.

// Esimerkki noista rajoittimista *J: Tuossa pari*

### TextEdit

The `TextEdit` item displays a block of editable, formatted text.

It can display both plain and rich text. For example:

```qml
TextEdit {
    width: 240
    text: "<b>Hello</b> <i>World!</i>"
    font.family: "Helvetica"
    font.pointSize: 20
    color: "blue"
    focus: true
}
```

// Nyt trakkana focuksen kanssa. Kun focus on true, niin item vasta pyytää fokusta. Siträ voisi tähän vähän avata. *J: Focus on nyt selitetty aiemmin*

Note that the `TextEdit` does not implement scrolling, following the cursor, or other behaviors specific to a look-and-feel. For example, to add flickable scrolling that follows the cursor:

```qml
Flickable {
    id: flick

    width: 300; height: 200;
    contentWidth: edit.paintedWidth
    contentHeight: edit.paintedHeight
    clip: true
    
    function ensureVisible(r) {
        if (contentX >= r.x)
            contentX = r.x;
        else if (contentX+width <= r.x+r.width)
            contentX = r.x+r.width-width;
        if (contentY >= r.y)
            contentY = r.y;
        else if (contentY+height <= r.y+r.height)
            contentY = r.y+r.height-height;
    }

    TextEdit {
        id: edit
        width: flick.width
        focus: true
        wrapMode: TextEdit.Wrap
        onCursorRectangleChanged: flick.ensureVisible(cursorRectangle)
    }
}
```

A particular look-and-feel might use smooth scrolling (eg. using `SmoothedAnimation`), might have a visible scrollbar, or a scrollbar that fades in to show location, etc.

Clipboard support is provided by the `cut()`, `copy()`, and `paste()` functions, and the selection can be handled in a traditional "mouse" mechanism by setting `selectByMouse`, or handled completely from QML by manipulating `selectionStart` and `selectionEnd`, or using `selectAll()` or `selectWord()`.

You can translate between cursor positions (characters from the start of the document) and pixel points using `positionAt()` and `positionToRectangle()`.

## Keys

// Miksi Keys--tyypistä ei voi luoda objektia. Nyt olis hyvä, jos attached properties olisi selitetty. Ei enää täällä  *J: 3.01:ssä on nyt aika laaja kappale propertyistä, ja sinne pitäisi lisätä vielä vähän visibility säännöistä. Olisikohan se visibility hyvä paikka selittää myös attached property ajatus ettei siitä tule liian irrallista?*

The `Keys` QML type is responsible for key handling. Keys can be handled via the `onPressed` and `onReleased` signal properties.

// Hyvä varmaan sanoa, että modifiersejä tuetaan ja shortcutteja

The signal properties have a `KeyEvent` parameter, named event which contains details of the event. If a key is handled `event.accepted` should be set to `true` to prevent the event from propagating up the item hierarchy.

The following example shows how the general `onPressed` handler can be used to test for a certain key; in this case, the left cursor key:

```qml
Item {
    anchors.fill: parent
    focus: true
    Keys.onPressed: {
        if (event.key == Qt.Key_Left) {
            console.log("move left");
            event.accepted = true;
        }
    }
}
```

Some keys may alternatively be handled via specific signal properties, for example `onSelectPressed`. These handlers automatically set `event.accepted` to `true`.

```qml
Item {
    anchors.fill: parent
    focus: true
    Keys.onLeftPressed: console.log("move left")
}
```

// Ottaisin jo 02:ssa tuon alemman lauseen ja joka tapauksessa ennen noita esimerkkejä. Voisi olla molemmissa paikoissa: 02 ja ennen näitä esimerkkejä

The `Keys` attached property can be configured to handle key events before or after the item it is attached to. This makes it possible to intercept events in order to override an item's default behavior, or act as a fallback for keys not handled by the item.

## Key handling priorities

// Tää alkaa jotenkin keskeltä aihetta. Aloittakaa ilman If:iä. The default processing order...

The default priority is `Keys.BeforeItem`, where the order of key event processing is:

1. Items specified in `forwardTo`
2. specific key handlers, e.g. `onReturnPressed`
3. `onPressed`, `onReleased` handlers
4. Item specific key handling, e.g. `TextInput` key handling
5. parent item

If priority is `Keys.AfterItem` the order of key event processing is:

1. Item specific key handling, e.g. `TextInput` key handling
2. Items specified in `forwardTo`
3. specific key handlers, e.g. `onReturnPressed`
4. `onPressed`, `onReleased` handlers
5. parent item

If the event is accepted during any of the above steps, key propagation stops.



## Key Handling Overview

When the user presses or releases a key, the following occurs:

1. Qt receives the key action and generates a key event.
2. If a `QQuickWindow` is the active window, the key event is delivered to it.
3. The key event is delivered by the scene to the `Item` with active focus. If no item has active focus, the key event is ignored.
4. If the `QQuickItem` with active focus accepts the key event, propagation stops. Otherwise the event is sent to the Item's parent until the event is accepted, or the root item is reached.

// Mistä kurssilainen tietää, mihin sen kannattaa laittaa key press -käsittely. Use caset olisi hyviä. Esim. toi window, jos halutaan kaikki key eventit kiinnin, ennen kuin ne on edes QML-enginellä

If the `Rectangle` type in the following example has active focus and the A key is pressed, the event will not be propagated further. Upon pressing the B key, the event will propagate to the root item and thus be ignored.

```qml
Rectangle {
    width: 100; height: 100
    focus: true
    Keys.onPressed: {
        if (event.key == Qt.Key_A) {
            console.log('Key A was pressed');
             event.accepted = true;
        }
    }
}
```
     
***

// Tästäkin sais kolme
// Perus key handling ja modifierit. Pitää vaikka vaan tulostaa consoleen, mitä tulee sisään
// Focus handling jollain nabilla eli se KeyNavigation
// Focus Scope

## Exercise - KeyHandling

Create a blue 50x50px Rectangle at the starting position x=175 and y=125 that moves 10px to the corresponding direction when arrow keys are pressed. 

Then implement functionality so that the rectangle changes color between blue and red when the Tab key is pressed.

You need to expose 3 properties. The color as boxColor and the x/y coordinates as xCoord and yCoord, respectively.

***

## Checklist for chapter 2.02

**Beginner**

* What is keyboard focus?
* What is mouse grab?
* What is keyboard grab?
* What is an attached property (Keys, for example)?

**Intermediate**

* How do you grab specific key presses?
* How do you grab generic key presses?
* How do you get focus?
* How do you change focus?
* What is FocusScope?

**Expert**

* How do you forward a key press to a parent?

***
