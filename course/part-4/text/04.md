# 4.04 - Delegates

Delegates act as templates for instantiating the visual items inside the view. The data roles provided by the model are bound to visual item properties, such as the `Text.text` or `Image.source` property. Delegates can also be used to modify and update the data bound to the roles. In the following example, we have a `TeamDelegate` that updates the bound data when clicked:

```qml
ListModel {
    id: teamModel
    ListElement {
        teamName: "Team C++"
        teamColor: "blue"
    }
}

ListView {
    anchors.fill: parent
    model: teamModel
    delegate: TeamDelegate {}
}

Component {
    Text {
        text: teamName
        color: teamColor

        MouseArea {
            anchors.fill: parent
            onClicked: {
                    model.teamName = "Team Quick"
                    model.teamColor = "red"
                }
            }
        }
    }
}

```

Within the delegate, we have access to the [data roles](http://doc.qt.io/qt-5/qtquick-modelviewsdata-modelview.html#qml-data-models) as internal properties. We also have the property `model` available to us, which can be used to access the roles without naming conflicts.

## Attached properties 

Each delegate gets an access to a number of attached properties, provided by the view. For example, `ListView` to which the delegate is bound is accessible from the delegate through the `ListView.view` property. Or a delegate can check, whether it is the current item by using `ListView.isCurrentItem`.

Attach properties allow implementing clean, re-usable delegates, which do not have direct bindings to the view via an `id`, for example. 

The attached properties are available to the root delegate item. Child objects must refer to attached properties using the root delegate identifier as in the following example. Sometimes a new custom var property, bound to an attached property, id declared. Remember however that each additional property increases the memory consumption.

```qml
GridView {
    width: 300; height: 200
    cellWidth: 80; cellHeight: 80
    model: contactsModel
    delegate: contactsDelegate

    Component {
        id: contactsDelegate
        Rectangle {
            id: rootWrapper
            width: 80
            height: 80
            // Rectangle is the root item, we can refer to the attached property directly
            color: GridView.isCurrentItem ? "black" : "red"
            Text {
                id: contactInfo
                text: name + ": " + number
                // Attached property is not accessible in the child
                color: rootWrapper.GridView.isCurrentItem ? "red" : "black"
            }
        }
    }

}
```

### Exercise special path with attached properties 

### Delegate size

In most examples, we have used `Text` QML types for delegates. This is because `Text` objects have implicit size. There has not been a need to explicitly define the delegate size.  

In real application, delegates seldom contain just a text or image, which both have an implicit size. As a delegate is a component, there must be exactly one root item. The `Item` QML type is a good candidate for the root item, as it's suitable for composing delegates from other items. However, `Item` has no explicit size, so we have to take care of declaring it. 

One approach is to bind the root item size to the view size. In the following example, we bind the delegate height to the height available for one item, assuming the model has `n` items. To keep the text readable, we have used `FontMetrics` to calculate the minimum height that we need to render the text properly. 

```qml
ListView {
    anchors.fill: parent
    anchors.margins: 20
    clip: true
    model: 50
    delegate: numberDelegate
}

FontMetrics {
    id: fontMetrics
    font { family: "Arial"; pixelSize: 14 }
}

Component {
    id: numberDelegate
    Item {
        width: ListView.view.width
        height: Math.max(ListView.view.height / ListView.view.count, fontMetrics.height)

        Rectangle {
            anchors.fill: parent
            border.color: "black"
            Text {
                font { family: "Arial"; pixelSize: 14}
                text: 'Item ' + index;
                anchors.centerIn: parent;
            }
        }
    }
}
```

Another approach is to let the children determine the delegate size. This is useful, if children have implicit size like the `Text` item in the following example. 

```qml
Component {
    id: numberDelegate
    Item {
        id: rootItem
        width: ListView.view.width
        height: childrenRect.height

        Rectangle {
            width: rootItem.width
            height: childrenRect.height + 2
            border.color: "black"
            Text {
                font { family: "Arial"; pixelSize: 14}
                text: 'Item ' + index;
            }
        }
    }
}
```

As a rule of thumb, avoid any complex size or layout calculations in delegates. They are created and destroyed frequently and should be as light-weight as possible. 

### Exercise sizes 

## Clip

The view `clip` property will ensure that any view items outside of the view will not be visible. If set `false`, items will 'flow over' the view. Avoid using `clip` in delegates.  If `clip` is enabled inside a delegate, each delegate will be batched separately. The QML renderer tries to optimise the number of OpenGL state changes, by batching paint operations. Less batches result to better rendering performance. Clipping results that delegates cannot be batched and each delegate will be submitted to OpenGL in its own batch. 

Read more about batches in [`Scenegraph renderer`](http://doc.qt.io/qt-5/qtquick-visualcanvas-scenegraph-renderer.html) 

### Exercise, clip rendering 

## Memory management

Dynamic views create and destroy delegates dynamically. The only exception is `TableView`, which is able to re-use existing delegates from the pool. `TableView` has a `reuseItems` property to control this. 

By default, `ListView`, `GridView`, and `PathView` will create as many delegate items, as are visible in the view. This allows Qt developers to use huge item models, consisting of millions of items, as only a portion of items are visible at the time. When a user flicks the view, existing items are destroyed and new ones are created. This means that you must never store state information into a delegate. Always store the state information into the model, before the item is destroyed.

```qml
Component.onDestruction: {
    someRoleName = (state === "false") ? false : true;
}
```

Views provide caches to improve the performance, when the user is flicking the view. `ListView` and `GridView` use `cacheBuffer`, while `PathView` uses `cacheItemCount`, which equals to cached delegate items, provided that the model contain more items than currently shown in the view `pathItemCount`. 

The property `cacheBuffer` is an integer, determining how many delegate items are cached. If the value is 100 in a list view and the delegate height is 20, 5 items will be cached before and 5 items will be cached after the currently visible items. 

In `GridView`, the caching principle is similar. If in a vertical view the delegate is 20 pixels high, there are 3 columns and `cacheBuffer` is set to 40, then up to 6 delegate items above and 6 delegate items below the visible area may be created or retained. 

`TableView` can also reuse delegate items. When an item is flicked out, it moves to the reuse pool, which is an internal cache of unused items. When this happens, the `TableView::pooled` signal is emitted to inform the item about it. Likewise, when the item is moved back from the pool, the `TableView::reused` signal is emitted.

Any item properties that come from the model are updated when the item is reused. This includes index, row, and column, but also any model roles.

Avoid storing any state inside a delegate. If you do, reset it manually on receiving the `TableView::reused` signal.

If an item has timers or animations, consider pausing them on receiving the `TableView::pooled` signal. That way you avoid using the CPU resources for items that are not visible. Likewise, if an item has resources that cannot be reused, they could be freed up.

The following example shows a delegate that animates a spinning rectangle. When it is pooled, the animation is temporarily paused.

```qml
Component {
    id: tableViewDelegate
    Rectangle {
        implicitWidth: 100
        implicitHeight: 50

        TableView.onPooled: rotationAnimation.pause()
        TableView.onReused: rotationAnimation.resume()

        Rectangle {
            id: rect
            anchors.centerIn: parent
            width: 40
            height: 5
            color: "green"

            RotationAnimation {
                id: rotationAnimation
                target: rect
                duration: (Math.random() * 2000) + 200
                from: 0
                to: 359
                running: true
                loops: Animation.Infinite
            }
        }
    }
}
```

### Exercise 

## Complex delegates

Before reading further, please consider keeping your delegates simple and stop reading. Try your best not to add any extra complexity to delegates. However, sometimes complex delegates may be required. 

Problems arise when delegates contain, for example [`Video`](https://doc.qt.io/qt-5/qml-qtmultimedia-video.html) items all auto-playing video for some odd reason.

```qml
Item {
    id: videoDelegate

    Video {
        id: video
        width: 800
        height: 600
        source: model.videosrc
        autoPlay: true
    }
}
```

The target platform is low-end devices, and loading all these items at startup will take an noticeable amount of time. Some devices might not be able to play multiple video sources at the same time.

If there is a need to load resource intensive items inside a delegate, it is possible to create objects dynamically, as explained in [Dynamic object creation](https://doc.qt.io/qt-5/qtqml-javascript-dynamicobjectcreation.html).

QML has the [Loader](https://doc.qt.io/qt-5/qml-qtquick-loader.html) type, which can be used to load different parts of the UI, like complicated parts of delegates, to improve performance. The following example has a delegate which has a `Component` where the video will be contained. We add a `Loader` and a `MouseArea` to the delegate, so when clicked the `sourceComponent` property will be set to the `videoComponent`. This change will trigger the `Loader` to load the `videoComponent` component.

```qml
Item {
    id: lazyVideoDelegate

    width: 200
    height: 200

    Component {
        id: videoComponent

        Video {
            id: video
            width: 800
            height: 600
            source: model.videosrc
            autoPlay: true
        }
    }

    Loader {
        id: videoLoader
    }

    MouseArea {
        anchors.fill: parent
        onClicked: videoLoader.sourceComponent = videoComponent
    }
}
```

Notice that while a `Video` item declared by itself would be automatically rendered and displayed, this is not the case for the above as the item is defined inside a Component.

This will reduce the load time considerably, as the delegate will only contain `Loader` and `MouseArea` objects initially. Note however that we have to create a `Loader` object, which is not free. It is lighter, but consumes memory anyway. The better way is to try to avoid `Loaders` in delegates. The best approach would be to add an `Image` which displays a thumbnail of the video or something similar.

### Exercise : Compare TableView/GridView 

***

### Exhaustive reference material mentioned in this topic

http://doc.qt.io/qt-5/model-view-programming.html  
https://qmlbook.github.io/en/ch06/index.html#delegate  
https://www.quora.com/What-are-delegates-in-Qt  
https://doc.qt.io/archives/qq/qq24-delegates.html  
http://doc.qt.io/qt-5/qitemdelegate.html  
https://www.ics.com/designpatterns/book/delegates.html  
http://doc.qt.io/archives/qt-4.8/qabstractitemdelegate.html#details  
http://doc.qt.io/qt-5/qitemdelegate.html#details  


### Further reading topics/links:


***

### Exhaustive reference material mentioned in this topic
https://doc.qt.io/qt-5/qml-qtquick-loader.html#using-a-loader-within-a-view-delegate

https://doc.qt.io/qt-5/qtqml-javascript-dynamicobjectcreation.html

https://doc.qt.io/qt-5/qtquick-performance.html#lazy-initialization

https://qmlbook.github.io/ch13/index.html

### Further reading topics/links: