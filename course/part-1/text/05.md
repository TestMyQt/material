# 1.05 Object Communicating: Signals and Slots

Now we're getting somewhere! Signals and slots are the key of Qt and object communication within. They are in a sense comparable to callbacks, but the difference is that they are type-safe where as callbacks typically are not. One of the benefits we could mention before starting, is that signals and slots allow you to build many-to-many connections, where as typically virtual methods are one-to-one or one-to-many, if several virtual functions are used.

We discussed the `Q_OBJECT` macro in chapter 1.03, and it will find some relevance throughout this topic as well.

### Signals

Signals are emitted by an object when its internal state has changed in some way that might be interesting to the object's client or owner. Signals are public access functions and can be emitted from anywhere, but we recommend to only emit them from the class that defines the signal and its subclasses.

When a signal is emitted, the slots connected to it are usually executed immediately, just like a normal function call. When this happens, the signals and slots mechanism is totally independent of any GUI event loop. Execution of the code following the `emit` statement will occur once all slots have returned. The situation is slightly different when using queued connections; in such a case, the code following the emit keyword will continue immediately, and the slots will be executed later.

Here are some examples of signals from the `QPushButton` class:

* clicked
* pressed
* released

As you can see, their names are quite explicit. These signals are sent when the user clicked (pressed then released), pressed or released the button.

Signals are automatically generated by the moc (meta-object compiler) and must not be implemented in the .cpp file. They can never have return types (i.e. use void).

A note about arguments: Our experience shows that signals and slots are more reusable if they do not use special types. If `QScrollBar::valueChanged()` were to use a special type such as the hypothetical `QScrollBar::Range`, it could only be connected to slots designed specifically for `QScrollBar`. Connecting different input widgets together would be impossible.

### Slots

A slot is called when a signal connected to it is emitted. Slots are normal C++ functions and can be called normally; their only special feature is that signals can be connected to them.

Here are some slots, from different classes:

* `QApplication::quit`
* `QWidget::setEnabled`
* `QPushButton::setText`

If several slots are connected to one signal, the slots will be executed one after the other, in the order they have been connected, when the signal is emitted.

Since slots are normal member functions, they follow the normal C++ rules when called directly. However, as slots, they can be invoked by any component, regardless of its access level, via a signal-slot connection. This means that a signal emitted from an instance of an arbitrary class can cause a private slot to be invoked in an instance of an unrelated class.

You can also define slots to be virtual, which we have found quite useful in practice.

Compared to callbacks, signals and slots are slightly slower because of the increased flexibility they provide, although the difference for real applications is insignificant. In general, emitting a signal that is connected to some slots, is approximately ten times slower than calling the receivers directly, with non-virtual function calls. This is the overhead required to locate the connection object, to safely iterate over all connections (i.e. checking that subsequent receivers have not been destroyed during the emission), and to marshall any parameters in a generic fashion. While ten non-virtual function calls may sound like a lot, it's much less overhead than any new or delete operation, for example. As soon as you perform a string, vector or list operation that behind the scene requires new or delete, the signals and slots overhead is only responsible for a very small proportion of the complete function call costs. The same is true whenever you do a system call in a slot; or indirectly call more than ten functions. The simplicity and flexibility of the signals and slots mechanism is well worth the overhead, which your users won't even notice.

Note that other libraries that define variables called signals or slots may cause compiler warnings and errors when compiled alongside a Qt-based application. To solve this problem, `#undef` the offending preprocessor symbol.

### Example Signal/Slot definition
```cpp
#include <QObject>

class Counter : public QObject
{
    Q_OBJECT

public:
    Counter() { m_value = 0; }

    int value() const { return m_value; }

public slots:
    void setValue(int value);

signals:
    void valueChanged(int newValue);

private:
    int m_value;
};
```

### Connecting Singnals and Slots

To connect the signal to the slot, we use `QObject::connect()`. There are several ways to connect signal and slots. The first is to use function pointers:

```cpp
connect(sender, &QObject::destroyed, this, &MyObject::objectDestroyed);
```

There are several advantages to using `QObject::connect()` with function pointers. First, it allows the compiler to check that the signal's arguments are compatible with the slot's arguments. Arguments can also be implicitly converted by the compiler, if needed.

You can also connect to functors or C++11 lambdas:

```cpp
connect(sender, &QObject::destroyed, [=](){ this->m_objects.remove(sender); });
```

The traditional way to connect a signal to a slot is to use `QObject::connect()` and the SIGNAL and SLOT macros. It's presented here because it's still widely used. In general case though, you should use one of the connection types presented before. The rule about whether to include arguments or not in the SIGNAL() and SLOT() macros, if the arguments have default values, is that the signature passed to the SIGNAL() macro must not have fewer arguments than the signature passed to the SLOT() macro.

All of these would work:

```cpp
connect(sender, SIGNAL(destroyed(QObject*)), this, SLOT(objectDestroyed(Qbject*)));
connect(sender, SIGNAL(destroyed(QObject*)), this, SLOT(objectDestroyed()));
connect(sender, SIGNAL(destroyed()), this, SLOT(objectDestroyed()));
```

But this one won't work:

```cpp
connect(sender, SIGNAL(destroyed()), this, SLOT(objectDestroyed(QObject*)));
```

...because the slot will be expecting a `QObject` that the signal will not send. This connection will report a runtime error. Note that signal and slot arguments are not checked by the compiler when using this `QObject::connect()` overload.

### The Observer Pattern

Nearly all UI toolkits have a mechanism to detect a user action, and respond to this action. Some of them use callbacks, others use listeners, but basically, all of them are inspired by the observer pattern.

Observer pattern is used when an observable object wants to notify other observers objects about a state change. Here are some concrete examples:

* A user has clicked on a button, and a menu should be displayed.
* A web page just finished loading, and a process should extract some information from this loaded page.
* An user is scrolling through a list of items (in an app store for example), and reached the end, so other items should be loaded.

Observer pattern is used everywhere in GUI applications, and often leads to some boilerplate code. Qt was created with the idea of removing this boilerplate code and providing a nice and clean syntax, and the signal and slots mechanism is the answer.

### Further Reading

For more detailed information about Signals and Slots, see [Signal/Slot documentation](https://doc.qt.io/qt-5/signalsandslots.html).

***

### Exercise - 05_SignalsSlots

Create classes `Sender` and `Receiver`.  

On `Sender` create functions `sendText(QString)` and `sendNumbers(int one, int two)` and define signals `textSignal(QString)` and `numberSignal(int f, int s)`.  

On `Receiver` create the corresponding slots `textSlot()` that uses `QDebug` to print out the message, and `numberSlot()` that uses `QDebug` to print out the sum.  

***

### Checklist for chapter 1.05

**Beginner**

* What is object communication?
* Why is object communication?
* What are callbacks?
* How do signals compare to callbacks?
* What does "type-safe" mean?

**Intermediate**

* What are Signals?  
* What are Slots?  
* How do Signals and Slots interconnect?  
* When to use Signals and Slots?  
* When to not use Signals and Slots? 

**Expert**

* What is the observer pattern?
* What are many-to-many observer connections?
* What kind of connection variants exist? (lambdas)

***
# Feedback

After finishing with Part 1, please take a moment to [give us feedback!](https://goo.gl/forms/1WMe6f03oFfDaHxW2). Feel free to submit several if you wish to say something while doing it too.
{: .note }
