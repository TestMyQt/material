# 1.02 - String handling and value types

In this chapter we're going to discuss strings and their manipulation, and also talk briefly about Value vs Identity type in Qt. There will be some details that are discussed more thoroughly, but in general we'll try to keep to a coherent and concise presentation. If you wish to read up on the more specific techincal details, we encourage you to check the official Qt documentation.

## QChar

`QChar` class provides a 16-bit Unicode character. In Qt, Unicode characters are 16-bit entities without any markup or structure, and this class represents such an entity. It's lightweight, so it can be used everywhere. Most compilers treat it like an usigned short. The class features many functions you'd expect, such as `isNull()` and `isNumber()`. If you wish to read more about `QChar`, see the [official documentation](https://doc.qt.io/qt-5/qchar.html).

## QString

The `QString` class provides a Unicode character string. `QString` stores a string of 16-bit `QChars`, where each `QChar` corresponds one Unicode 4.0 character. (Unicode characters with code values above 65535 are stored using surrogate pairs, i.e., two consecutive `QChars`.)

Behind the scenes, `QString` uses implicit sharing (copy-on-write) to reduce memory usage and to avoid the needless copying of data. This also helps reduce the inherent overhead of storing 16-bit characters instead of 8-bit characters.

In addition to `QString`, Qt also provides the `QByteArray` class to store raw bytes and traditional 8-bit '\0'-terminated strings. For most purposes, `QString` is the class you want to use. It is used throughout the Qt API, and the Unicode support ensures that your applications will be easy to translate if you want to expand your application's market at some point. The two main cases where `QByteArray` is appropriate are when you need to store raw binary data, and when memory conservation is critical (like in embedded systems).

### Initializing a String

One way to initialize a `QString` is simply to pass a `const char *` to its constructor. For example, the following code creates a `QString` of size 5 containing the data "Hello":

```cpp
QString str = "Hello";
```

Other ways exist too, such as providing the string data as an array of `QChars`.

Another approach is to set the size of the string using `resize()`, and to initialize the data character per character using the `[]` operator, e.g. `str[2] = QChar('A')`. After a call to the `resize()` function, the newly allocated characters have undefined values. To set all the characters in the string to a particular value, use the `fill()` function.

For read-only access, an alternative syntax is to use the `at()` function. The `at()` function can be faster than `operator[]()`, because it never causes a deep copy to occur.

`QString` provides dozens of overloads designed to simplify string usage. For example, if you want to compare a QString with a string literal, you can write code like this and it will work as expected:

```cpp
QString str;
if (str == "auto" || str == "extern" || str == "static" || str == "register") {
    // ...
}
```

You can also pass string literals to functions that take `QString`s as arguments, invoking the `QString(const char *)` constructor.

### Manipulating String Data

`QString` provides the following basic functions for modifying the character data: `append()`, `prepend()`, `insert()`, `replace()`, and `remove()`. For example:

```cpp
QString str = "and";
str.prepend("rock "); // str == "rock and"
str.append(" roll"); // str == "rock and roll"
str.replace(5, 3, "&"); // str == "rock & roll"
```

If you are building a `QString` gradually and know in advance approximately how many characters the `QString` will contain, you can call `reserve()`, asking `QString` to preallocate a certain amount of memory. You can also call `capacity()` to find out how much memory `QString` actually allocated.

A frequent requirement is to remove whitespace characters from a string ('\n', '\t', ' ', etc.). If you want to remove whitespace from both ends of a `QString`, use the `trimmed()` function. If you want to remove whitespace from both ends and replace multiple consecutive whitespaces with a single space character within the string, use `simplified()`.

`indexOf()` and `lastIndexOf()` functions return the first index position of the character or substring they find, former going forward from given position, and latter backwards; if none is found they return -1.

Lists of strings are handled by the `QStringList` class. You can split a string into a list of strings using the `split()` function, and join a list of strings into a single string with an optional separator using `QStringList::join()`. You can obtain a list of strings from a string list that contain a particular substring or that match a particular `QRegExp` using the `QStringList::filter()` function.

### Exercise - Create String and concatenate

### Conversions

QString provides the following three functions that return a `const char *` version of the string as `QByteArray`: `toUtf8()`, `toLatin1()`, and `toLocal8Bit()`. Corresponding functions to convert from these encodings are `fromLatin1()`, `fromUtf8()`, and `fromLocal8Bit()`. Other encodings are supported through the `QTextCodec` class.

#### QTextCodec

Qt uses Unicode to store, draw and manipulate strings. In many situations you may wish to deal with data that uses a different encoding. For example, most Japanese documents are still stored in Shift-JIS or ISO 2022-JP, while Russian users often have their documents in KOI8-R or Windows-1251. The `QTextCodec` class provides conversions between text encodings. We aren't diving into different encodings on this course, but if you're interested in learning about it, please visit [QTextCodec documentation](http://doc.qt.io/qt-5/qtextcodec.html).

### Distinction Between Null and Empty Strings

For historical reasons, `QString` distinguishes between a null string and an empty string. A null string is a string that is initialized using `QString`'s default constructor or by passing `const char *` 0 to the constructor. An empty string is any string with size 0. Thus, null string is always empty, but an empty string isn't necessarily null (e.g. `QString()` is both null and empty, `QString("")` is empty, but not null).

All functions except `isNull()` treat null strings the same as empty strings. For example, `toUtf8().constData()` returns a pointer to a '\0' character for a null string (not a null pointer), and `QString()` compares equal to `QString("")`. We recommend that you always use the `isEmpty()` function and avoid `isNull()`.

### More Efficient String Construction

*This section could be cut down even more, but for now I don't think it's too long*

Many strings are known at compile time. But the trivial constructor `QString("Hello")`, will copy the contents of the string, treating the contents as Latin-1. To avoid this one can use the `QStringLiteral` macro to directly create the required data at compile time. Constructing a `QString` out of the literal does then not cause any overhead at runtime.

A slightly less efficient way is to use `QLatin1String`. This class wraps a C string literal, precalculates it length at compile time and can then be used for faster comparison with `QString`s and conversion to `QString`s than a regular C string literal.

Using the `QString` '+' operator, it is easy to construct a complex string from multiple substrings. You will often write code like this:

```cpp
QString foo;
QString type = "long";

foo->setText(QLatin1String("vector<") + type + QLatin1String(">::iterator"));

if (foo.startsWith("(" + type + ") 0x"))
    ...
```

There is nothing wrong with either of these string constructions, but there are a few hidden inefficiencies. Beginning with Qt 4.6, you can eliminate them.

First, multiple uses of the '+' operator usually means multiple memory allocations. When concatenating n substrings, where n > 2, there can be as many as n - 1 calls to the memory allocator.

In Qt 4.6, an internal template class `QStringBuilder` has been added along with a few helper functions. This class is marked internal and does not appear in the documentation, because you aren't meant to instantiate it in your code. Its use will be automatic, as described below. The class is found in `src/corelib/tools/qstringbuilder.cpp` if you want to have a look at it.

`QStringBuilder` uses expression templates and reimplements the '%' operator so that when you use '%' for string concatenation instead of '+', multiple substring concatenations will be postponed until the final result is about to be assigned to a `QString`. At this point, the amount of memory required for the final result is known. The memory allocator is then called once to get the required space, and the substrings are copied into it one by one.

There are two ways you can access this improved method of string construction. The straightforward way is to include `QStringBuilder` wherever you want to use it, and use the '%' operator instead of '+' when concatenating strings:

```cpp
#include <QStringBuilder>

QString hello("hello");
QStringRef el(&hello, 2, 3);
QLatin1String world("world");
QString message =  hello % el % world % QChar('!');
```

A more global approach which is the most convenient, but not entirely source compatible, is to this define in your .pro file:

```qmake
DEFINES *= QT_USE_QSTRINGBUILDER
```

and the '+' will automatically be performed as the QStringBuilder '%' everywhere.

### Exercise - Playing around with substrings

## QByteArray

The [`QByteArray`](http://doc.qt.io/qt-5/qbytearray.html) class provides an array of bytes.

`QByteArray` can be used to store both raw bytes and traditional 8-bit '`\0`'-terminated strings. Using `QByteArray` is often much more convenient than using `const char *`. Behind the scenes, it always ensures that the data is followed by a '`\0`' terminator, and uses implicit sharing (copy-on-write) to reduce memory usage and avoid needless copying of data.

One way to initialize a `QByteArray` is simply to pass a `const char *` to its constructor. For example, the following code creates a byte array of size 5 containing the data "Hello":

```cpp
QByteArray ba("Hello");
```

Although the `size()` is 5, the byte array also maintains an extra '`\0`' character at the end so that if a function is used that asks for a pointer to the underlying data (e.g. a call to `data()`), the data pointed to is guaranteed to be '`\0`'-terminated.

A `QByteArray` can embed '`\0`' bytes. The `size()` function always returns the size of the whole array, including embedded '`\0`' bytes, but excluding the terminating '`\0`' added by `QByteArray`. If you want to obtain the length of the data up to and excluding the first '`\0`' character, call `qstrlen()` on the byte array.

As with `QString` you can also set the size of the array using `resize()` and then initialize the data byte per byte using `operator[]()`.

To obtain a pointer to the actual character data, call `data()` or `constData()`. These functions return a pointer to the beginning of the data. The pointer is guaranteed to remain valid until a non-const function is called on the `QByteArray`.

`QByteArray` provides the same functions for modifying and searching the byte data as `QString`, such as `append()` and `indexOf()`.

Functions that perform conversions between numeric data types and strings are performed in the C locale, irrespective of the user's locale settings. Use `QString` to perform locale-aware conversions between numbers and strings.

In QByteArray, the notion of uppercase and lowercase and of which character is greater than or less than another character is locale dependent. This affects functions that support a case insensitive option, or that compare, or lowercase or uppercase their arguments. Case insensitive operations and comparisons will be accurate if both strings contain only ASCII characters. (If $LC_CTYPE is set, most Unix systems do "the right thing".) This issue does not apply to `QString`s since they represent characters using Unicode.

## Exercise - QByteArray

## Value Type vs Identity Type

Let's talk shortly about Value vs Identity type in Qt. All the objects discussed in this chapter, such as `QString`, are value types, meaning that they can be copied. Later on in the course we will be going into `Qt Objects` which are identity types. The difference here is that where values are assigned and copied, identities are cloned. Cloning means to create a new identity, not an exact copy of the old one. If you wish to learn more about the reasoning behind this, [see documenation](https://doc.qt.io/qt-5/object.html).

### QVariant

Later in the course we will be using `QVariant`, so we'll talk about it here briefly. The `QVariant` class acts like a union for the most common Qt data types, specifically value types. Because C++ forbids unions from including types that have non-default constructors or destructors, most interesting Qt classes cannot be used in unions. `QVariant` solves this problem. A `QVariant` object holds a single value of a single `type()` at a time. (Some `type()`s are multi-valued, for example a string list.) You can find out what type, `T`, the variant holds, convert it to a different type using `convert()`, get its value using one of the `toT()` functions (e.g., `toSize()`) and check whether the type can be converted to a particular type using `canConvert()`. See [QVariant documentation](https://doc.qt.io/qt-5/qvariant.html) for further details.

## Exercise - QVariant

******