# 1.02 - String handling and value types

#### The intro needs rewriting too, but will be done after the rest of the chapter is more clear

As our next topic we're going to take a look at some basic string manipulation, and some value types. We'll also take a brief look at how to compare and manipulate strings efficiently.  
To start, Qt has it's own type `QString` replacing standard string, and it's implicitly shared. Implicit sharing in Qt types is discussed at length later in the material. If you should walk away from this topic with something in mind, it is that Qt does have literals, and that it does make sense to use mutable strings in situations where literals are ok, such as file names.

We will start with string manipulation, after which we will take a comparative look at QString and QByteArray. After that, we will take a look at how `std::string` and C string compares to QString, followed by a brief discussion about how to compare and manipulate strings efficiently. Lastly, we will discuss value types in Qt.

## QChar

`QChar` class provides a 16-bit Unicode character. In Qt, Unicode characters are 16-bit entities without any markup or structure, and this class represents such an entity. It's lightweight, so it can be used everywhere. Most compilers treat it like an usigned short. The class features many functions you'd expect, such as `isNull()` and `isNumber()`. If you wish to read more about `QChar` feel free to visit the [official documentation](https://doc.qt.io/qt-5/qchar.html).

## QString

The `QString` class provides a Unicode character string. `QString` stores a string of 16-bit `QChars`, where each `QChar` corresponds one Unicode 4.0 character. (Unicode characters with code values above 65535 are stored using surrogate pairs, i.e., two consecutive `QChars`.)

Behind the scenes, `QString` uses implicit sharing (copy-on-write) to reduce memory usage and to avoid the needless copying of data. This also helps reduce the inherent overhead of storing 16-bit characters instead of 8-bit characters.

In addition to `QString`, Qt also provides the `QByteArray` class to store raw bytes and traditional 8-bit '\0'-terminated strings. For most purposes, `QString` is the class you want to use. It is used throughout the Qt API, and the Unicode support ensures that your applications will be easy to translate if you want to expand your application's market at some point. The two main cases where `QByteArray` is appropriate are when you need to store raw binary data, and when memory conservation is critical (like in embedded systems).

### Initializing a String

One way to initialize a `QString` is simply to pass a `const char *` to its constructor. For example, the following code creates a `QString` of size 5 containing the data "Hello":

```cpp
QString str = "Hello";
```

Other ways exist too, such as providing the string data as an array of `QChars`.

Another approach is to set the size of the string using `resize()`, and to initialize the data character per character using the `[]` operator, e.g. `str[2] = QChara('A')`. After a call to the `resize()` function, the newly allocated characters have undefined values. To set all the characters in the string to a particular value, use the `fill()` function.

For read-only access, an alternative syntax is to use the `at()` function. The `at()` function can be faster than `operator[]()`, because it never causes a deep copy to occur.

`QString` provides dozens of overloads designed to simplify string usage. For example, if you want to compare a QString with a string literal, you can write code like this and it will work as expected:

```cpp
QString str;
if (str == "auto" || str == "extern" || str == "static" || str == "register") {
    // ...
}
```

You can also pass string literals to functions that take `QString`s as arguments, invoking the `QString(const char *)` constructor.

### Manipulating String Data

`QString` provides the following basic functions for modifying the character data: `append()`, `prepend()`, `insert()`, `replace()`, and `remove()`. For example:

```cpp
QString str = "and";
str.prepend("rock "); // str == "rock and"
str.append(" roll"); // str == "rock and roll"
str.replace(5, 3, "&"); // str == "rock & roll"
```

If you are building a `QString` gradually and know in advance approximately how many characters the `QString` will contain, you can call `reserve()`, asking `QString` to preallocate a certain amount of memory. You can also call `capacity()` to find out how much memory `QString` actually allocated.

A frequent requirement is to remove whitespace characters from a string ('\n', '\t', ' ', etc.). If you want to remove whitespace from both ends of a `QString`, use the `trimmed()` function. If you want to remove whitespace from both ends and replace multiple consecutive whitespaces with a single space character within the string, use `simplified()`.

`indexOf()` and `lastIndexOf()` functions return the first index position of the character or substring they find, former going forward from given position, and latter backwards; if none is found they return -1.

Lists of strings are handled by the `QStringList` class. You can split a string into a list of strings using the `split()` function, and join a list of strings into a single string with an optional separator using `QStringList::join()`. You can obtain a list of strings from a string list that contain a particular substring or that match a particular `QRegExp` using the `QStringList::filter()` function.

### Conversions

QString provides the following three functions that return a `const char *` version of the string as `QByteArray`: `toUtf8()`, `toLatin1()`, and `toLocal8Bit()`. Corresponding functions to convert from these encodings are `fromLatin1()`, `fromUtf8()`, and `fromLocal8Bit()`. Other encodings are supported through the `QTextCodec` class.

### Distinction Between Null and Empty Strings

For historical reasons, `QString` distinguishes between a null string and an empty string. A null string is a string that is initialized using `QString`'s default constructor or by passing `const char *` 0 to the constructor. An empty string is any string with size 0. Thus, null string is always empty, but an empty string isn't necessarily null (e.g. `QString()` is both null and empty, `QString("")` is empty, but not null).

All functions except `isNull()` treat null strings the same as empty strings. For example, `toUtf8().constData()` returns a pointer to a '\0' character for a null string (not a null pointer), and `QString()` compares equal to `QString("")`. We recommend that you always use the `isEmpty()` function and avoid `isNull()`.

### More Efficient String Construction

Many strings are known at compile time. But the trivial constructor `QString("Hello")`, will copy the contents of the string, treating the contents as Latin-1. To avoid this one can use the `QStringLiteral` macro to directly create the required data at compile time. Constructing a `QString` out of the literal does then not cause any overhead at runtime.

A slightly less efficient way is to use `QLatin1String`. This class wraps a C string literal, precalculates it length at compile time and can then be used for faster comparison with `QString`s and conversion to `QString`s than a regular C string literal.

Using the `QString` '+' operator, it is easy to construct a complex string from multiple substrings. You will often write code like this:

```cpp
QString foo;
QString type = "long";

foo->setText(QLatin1String("vector<") + type + QLatin1String(">::iterator"));

if (foo.startsWith("(" + type + ") 0x"))
    ...
```

There is nothing wrong with either of these string constructions, but there are a few hidden inefficiencies. Beginning with Qt 4.6, you can eliminate them.

First, multiple uses of the '+' operator usually means multiple memory allocations. When concatenating n substrings, where n > 2, there can be as many as n - 1 calls to the memory allocator.

In 4.6, an internal template class `QStringBuilder` has been added along with a few helper functions. This class is marked internal and does not appear in the documentation, because you aren't meant to instantiate it in your code. Its use will be automatic, as described below. The class is found in `src/corelib/tools/qstringbuilder.cpp` if you want to have a look at it.

`QStringBuilder` uses expression templates and reimplements the '%' operator so that when you use '%' for string concatenation instead of '+', multiple substring concatenations will be postponed until the final result is about to be assigned to a `QString`. At this point, the amount of memory required for the final result is known. The memory allocator is then called once to get the required space, and the substrings are copied into it one by one.

Additional efficiency is gained by inlining and reduced reference counting (the `QString` created from a `QStringBuilder` typically has a ref count of 1, whereas `QString::append()` needs an extra test).

There are two ways you can access this improved method of string construction. The straightforward way is to include `QStringBuilder` wherever you want to use it, and use the '%' operator instead of '+' when concatenating strings:

```cpp
#include <QStringBuilder>

QString hello("hello");
QStringRef el(&hello, 2, 3);
QLatin1String world("world");
QString message =  hello % el % world % QChar('!');
```

A more global approach which is the most convenient, but not entirely source compatible, is to this define in your .pro file:

```qmake
DEFINES *= QT_USE_QSTRINGBUILDER
```

and the '+' will automatically be performed as the QStringBuilder '%' everywhere.

### Comparing and manipulating strings efficiently

The `QLatin1String` class provides a thin wrapper around an US-ASCII/Latin-1 encoded string literal.

Many of `QString`'s member functions are overloaded to accept `const char *` instead of `QString`. This includes the copy constructor, the assignment operator, the comparison operators, and various other functions such as `insert()`, `replace()`, and `indexOf()`. These functions are usually optimized to avoid constructing a `QString` object for the `const char *` data. For example, assuming str is a `QString`,

```cpp
if (str == "auto" || str == "extern" || str == "static" || str == "register") {
    ...
}
```

is much faster than

```cpp
if (str == QString("auto") || str == QString("extern") || str == QString("static") || str == QString("register")) {
    ...
}
```

because it doesn't construct four temporary `QString` objects and make a deep copy of the character data.

**Note**: If the function you're calling with a `QLatin1String` argument isn't actually overloaded to take `QLatin1String`, the implicit conversion to `QString` will trigger a memory allocation, which is usually what you want to avoid by using `QLatin1String` in the first place. In those cases, using `QStringLiteral` may be the better option.

## QTextCodec

Qt uses Unicode to store, draw and manipulate strings. In many situations you may wish to deal with data that uses a different encoding. For example, most Japanese documents are still stored in Shift-JIS or ISO 2022-JP, while Russian users often have their documents in KOI8-R or Windows-1251. The `QTextCodec` class provides conversions between text encodings. We aren't diving into different encodings on this course, but if you're interested in learning about it, please visit [QTextCodec documentation](http://doc.qt.io/qt-5/qtextcodec.html).

## QByteArray

The [`QByteArray`](http://doc.qt.io/qt-5/qbytearray.html) class provides an array of bytes.

`QByteArray` can be used to store both raw bytes and traditional 8-bit '`\0`'-terminated strings. Using `QByteArray` is often much more convenient than using `const char *`. Behind the scenes, it always ensures that the data is followed by a '`\0`' terminator, and uses implicit sharing (copy-on-write) to reduce memory usage and avoid needless copying of data.

One way to initialize a `QByteArray` is simply to pass a `const char *` to its constructor. For example, the following code creates a byte array of size 5 containing the data "Hello":

```cpp
QByteArray ba("Hello");
```

Although the `size()` is 5, the byte array also maintains an extra '`\0`' character at the end so that if a function is used that asks for a pointer to the underlying data (e.g. a call to `data()`), the data pointed to is guaranteed to be '`\0`'-terminated.

A `QByteArray` can embed '`\0`' bytes. The `size()` function always returns the size of the whole array, including embedded '`\0`' bytes, but excluding the terminating '`\0`' added by `QByteArray`. If you want to obtain the length of the data up to and excluding the first '`\0`' character, call `qstrlen()` on the byte array.

As with `QString` you can also set the size of the array using `resize()` and then initialize the data byte per byte using `operator[]()`.

To obtain a pointer to the actual character data, call `data()` or `constData()`. These functions return a pointer to the beginning of the data. The pointer is guaranteed to remain valid until a non-const function is called on the `QByteArray`.

`QByteArray` provides the same functions for modifying and searching the byte data as `QString`, such as `append()` and `indexOf()`.

Functions that perform conversions between numeric data types and strings are performed in the C locale, irrespective of the user's locale settings. Use `QString` to perform locale-aware conversions between numbers and strings.

In QByteArray, the notion of uppercase and lowercase and of which character is greater than or less than another character is locale dependent. This affects functions that support a case insensitive option, or that compare, or lowercase or uppercase their arguments. Case insensitive operations and comparisons will be accurate if both strings contain only ASCII characters. (If $LC_CTYPE is set, most Unix systems do "the right thing".) This issue does not apply to `QString`s since they represent characters using Unicode.

******

## Exercise - 02_Strings

1) Create a QString with the text "Qt rules " and then add the number "42" to it using QStrings appending function. Then print it the QDebug output.  

2) Use the same QString. Use insert to add the word "always" after the first word, and then print the string with QDebug. 
 
3) Make a copy of the string and use a loop to append it to the original (seperated by a space) 10 times. Again print the string with QDebug.  

4) Count the amount of times "Qt" appears in the string print out "Qt appeared x times" with QDebug.

******

## Checklist for chapter 1.01

**Intermediate**

* What is QString?
* QString vs QByteArray?
* How does std::string/c string compare to QString?
* How do you compare and manipulate strings efficiently (QLatin1String, QStringRef, ((QStringView)))?
* What are value types in Qt?

**Expert**

* What is QStringLiteral?
* What is QStringView?

******
