# 1.03 - Item Containers

## Qt Containers

The Qt library provides a set of general purpose template-based container classes. These classes can be used to store items of a specified type. For example, if you need a resizable array of QStrings, use `QVector<QString>`.

These container classes are designed to be lighter, safer, and easier to use than the [STL containers](http://www.cplusplus.com/reference/stl/). If you are unfamiliar with the STL, or prefer to do things the "Qt way", you can use these classes instead of the STL classes. However, it's completely fine to use standard containers as well.  

The Qt container classes are [implicitly shared](https://doc.qt.io/qt-5/implicit-sharing.html), they are [reentrant](https://doc.qt.io/qt-5/threads-reentrancy.html), and they are optimized for speed, low memory consumption, and minimal inline code expansion, resulting in smaller executables. In addition, they are thread-safe in situations where they are used as read-only containers by all threads used to access them.

For traversing the items stored in a container, you can use one of two types of iterators: Java-style iterators and STL-style iterators. The Java-style iterators are easier to use and provide high-level functionality, whereas the STL-style iterators are slightly more efficient and can be used together with Qt's and STL's generic algorithms.

Qt also offers a `foreach` keyword that make it very easy to iterate over all the items stored in a container.

## Container classes

Qt provides the following sequential containers: `QList`, `QLinkedList`, `QVector`, `QStack`, and `QQueue`. For most applications, `QVector` is the best type to use unless you have a specific need for the other ones.

Qt also provides these associative containers: `QMap`, `QMultiMap`, `QHash`, `QMultiHash`, and `QSet`. The "Multi" containers conveniently support multiple values associated with a single key. The "Hash" containers provide faster lookup by using a hash function instead of a binary search on a sorted set.

As special cases, the `QCache` and `QContiguousCache` classes provide efficient hash-lookup of objects in a limited cache storage.

Containers can be nested. For example, it is perfectly possible to use a `QMap<QString, QList<int>>`, where the key type is `QString` and the value type `QList<int>`.

The containers are defined in individual header files with the same name as the container (e.g., `<QLinkedList>`). For convenience, the containers are forward declared in `<QtContainerFwd>`.

The values stored in the various containers can be of any assignable data type. To qualify, a type must provide a default constructor, a copy constructor, and an assignment operator. This covers most data types you are likely to want to store in a container, including basic types such as int and double, pointer types, and Qt data types such as QString, QDate, and QTime, but it doesn't cover QObject or any QObject subclass (QWidget, QDialog, QTimer, etc.). If you attempt to instantiate a `QList<QWidget>`, the compiler will complain that QWidget's copy constructor and assignment operators are disabled. If you want to store these kinds of objects in a container, store them as pointers, for example as `QList<QWidget *>`.

Here's an example custom data type that meets the requirement of an assignable data type:

```cpp
class Employee
{
public:
     Employee() {}
     Employee(const Employee &other);

     Employee &operator=(const Employee &other);

 private:
      QString myName;
      QDate myDateOfBirth;
};
```

If we don't provide a copy constructor or an assignment operator, C++ provides a default implementation that performs a member-by-member copy. In the example above, that would have been sufficient. Also, if you don't provide any constructors, C++ provides a default constructor that initializes its member using default constructors. Although it doesn't provide any explicit constructors or assignment operator, the following data type can be stored in a container:

```cpp
struct Movie
{
    int id;
    QString title;
    QDate releaseDate;
};
```

Some containers have additional requirements for the data types they can store. For example, the Key type of a `QMap<Key, T>` must provide `operator<()`. Such special requirements are documented in a class's detailed description. In some cases, specific functions have special requirements; these are described on a per-function basis. The compiler will always emit an error if a requirement isn't met.

Qt's containers provide `operator<<()` and `operator>>()` so that they can easily be read and written using a `QDataStream`. This means that the data types stored in the container must also support `operator<<()` and `operator>>()`. Providing such support is straightforward; here's how we could do it for the Movie struct above:

```cpp
QDataStream &operator<<(QDataStream &out, const Movie &movie)
{
    out << (quint32)movie.id << movie.title
        << movie.releaseDate;
    return out;
}

QDataStream &operator>>(QDataStream &in, Movie &movie)
{
    quint32 id;
    QDate date;

    in >> id >> movie.title >> date;
    movie.id = (int)id;
    movie.releaseDate = date;
    return in;
}
```

The documentation of certain container class functions refer to default-constructed values; for example, `QVector` automatically initializes its items with default-constructed values, and `QMap::value()` returns a default-constructed value if the specified key isn't in the map. For most value types, this simply means that a value is created using the default constructor (e.g. an empty string for `QString`). But for primitive types like `int` and `double`, as well as for pointer types, the C++ language doesn't specify any initialization; in those cases, Qt's containers automatically initialize the value to 0.

## Iterating correctly and efficiently

Iterators provide a uniform means to access items in a container. Qt's container classes provide two types of iterators: Java-style iterators and STL-style iterators.

Non-mutable iterating can be done with a simple range loop `for (const &noteConstRefToMyItem : container)`.

The Java-style iterators were introduced in Qt 4. In some ways they are more convenient to use than the STL-style iterators, at the price of being slightly less efficient. Their API is modelled on Java's iterator classes.

In general we don't recommend using the normal Java-style iterators, though you may if you wish. For mutable iterating, the Java-style mutable iterators are arguably easiest to use.

Example of `QMutableListIterator`:

```cpp
QMutableListIterator<int> i(list);
while (i.hasNext()) {
    if (i.next() % 2 != 0)
        i.remove();
}
```

The code removes all odd numbers from the list. 

The `next()` call in the loop is made every time. It jumps over the next item in the list. The `remove()` function removes the last item that we jumped over from the list. The call to `remove()` does not invalidate the iterator, so it is safe to continue using it. 

If we just want to modify the value of an existing item, we can use `setValue()`. In the code below, we replace any value larger than 128 with 128:

```cpp
QMutableListIterator<int> i(list);
while (i.hasNext()) {
    if (i.next() > 128)
        i.setValue(128);
}
```

Iterators for associative containers work slightly differently, but the idea is the same. The [official documentation](http://doc.qt.io/qt-5/containers.html#the-iterator-classes) goes over different iterators in depth, and includes multiple examples as well.

***

## Exercise - 04_Containers

In this exercise you'll get familiar with `QVector` and `QMap`, exercise instuctions can be found in `containers.cpp`.

## Exercise - 05_VectorVictor

The final exercise for Part 1 is still a bit WIP, coming soon to IDE's near you.

***

## Algorithms in container manipulation

If you are interested in learning about algorithmic complexities of Qt Containers and data types please check out the documentation [here](http://doc.qt.io/qt-5/containers.html#algorithmic-complexity). In many ways it is good to understand why certain containers are better for some things than others, and in some applications even focusing on most efficient growth strategies, but it's past the goal of this course to go through them here.

***
